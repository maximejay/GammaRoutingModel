!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
MODULE MOD_GAMMA_ROUTING_PARAMETERS_DIFF_D_D_D_D_D_D
  IMPLICIT NONE
! damping coefficient in seconds (s/m): spreading of the Gamma law
  TYPE TYPE_ROUTING_PARAMETER
      REAL, DIMENSION(:), ALLOCATABLE :: hydraulics_coefficient
      REAL, DIMENSION(:), ALLOCATABLE :: spreading
  END TYPE TYPE_ROUTING_PARAMETER

CONTAINS
  SUBROUTINE ROUTING_PARAMETER_SELF_INITIALISATION(routing_parameter, &
&   routing_setup, routing_mesh, hydraulics_coefficient, spreading)
! Notes
! -----
! **routing_parameter_self_initialisation(routing_parameter,routing_setup,routing_mesh,hydraulics_coefficient,spreading)** :
!
! - Initialise the routing_parameter derived type with user values, allocate all components and set user values for all nodes
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_parameter``                   routing_parameter Derived Type (inout)
! ``routing_setup``                       routing_setup Derived Type (inout)
! ``routing_mesh``                        Routing_mesh Derived Type (inout)
! ``hydraulics_coefficient=1.``           Value of the hydraulic coefficient (optional)
! ``spreading=dt./dx.``                   Value of the spreading coefficient, default is set to dt (in second/m)(optional)
! =============================           ===================================
    USE MOD_GAMMA_ROUTING_SETUP
    USE MOD_GAMMA_ROUTING_MESH
    IMPLICIT NONE
!reading parameter
!setting parameter
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    REAL, OPTIONAL, INTENT(IN) :: hydraulics_coefficient
    REAL, OPTIONAL, INTENT(IN) :: spreading
    INTRINSIC ALLOCATED
    INTRINSIC PRESENT
    IF (.NOT.ALLOCATED(routing_parameter%hydraulics_coefficient)) THEN
      ALLOCATE(routing_parameter%hydraulics_coefficient(routing_mesh%&
&     nb_nodes))
    END IF
    IF (.NOT.ALLOCATED(routing_parameter%spreading)) THEN
      ALLOCATE(routing_parameter%spreading(routing_mesh%nb_nodes))
    END IF
    IF (PRESENT(hydraulics_coefficient)) THEN
      routing_parameter%hydraulics_coefficient = hydraulics_coefficient
    ELSE
!default value
      routing_parameter%hydraulics_coefficient = 1.0
    END IF
    IF (PRESENT(spreading)) THEN
! given in s/m 
      routing_parameter%spreading = spreading
    ELSE
!default value
      routing_parameter%spreading = routing_setup%dt/routing_mesh%dx
    END IF
  END SUBROUTINE ROUTING_PARAMETER_SELF_INITIALISATION

  SUBROUTINE ROUTING_PARAMETER_CLEAR(routing_parameter)
    IMPLICIT NONE
! Notes
! -----
! **routing_parameter_clear(routing_parameter)** :
!
! - Clear the derived type routing_parameter
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_parameter``                   routing_parameter Derived Type (inout)
! =============================           ===================================
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
    TYPE(TYPE_ROUTING_PARAMETER) :: routing_parameter_new
    routing_parameter = routing_parameter_new
  END SUBROUTINE ROUTING_PARAMETER_CLEAR

END MODULE MOD_GAMMA_ROUTING_PARAMETERS_DIFF_D_D_D_D_D_D

!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
MODULE MOD_GAMMA_ROUTING_STATES_DIFF_D_D_D_D_D_D
  IMPLICIT NONE
! length of the delay windows (model memory)
!number of discretization mode
!number of discretization spreads
!the highest mode i.e for vmin and dx max
!the lowest mode i.e for vmax and dx min
!the highest spreading values in s/m
!shift so that the peak of the PDF is located at x=dmin/vmax
!real :: max_scale !uniform scale coefficient computed thanks to the max_spread coeff
!non uniform scale coefficient computed thanks to the max_spread coeff
!Array of factor to normaize the model parameters (hydraulic_coeff, spreading)
!quantiles series to compute the Gamma pdf/cdf 
!tabulated delay (or mode) to locate the Gamma pdf
!tabulated spreading to spread the Gamma pdf
!real,dimension(:,:,:), allocatable :: tabulated_routing_coef !tabulated routing coefficient for the unit hydrogram
!tabulated routing coefficient for the unit hydrogram
!state of the system at t0
!remainder for the routing scheme
  TYPE TYPE_ROUTING_STATES
      INTEGER, DIMENSION(:), ALLOCATABLE :: window_length
      INTEGER :: nb_mode
      INTEGER :: nb_spreads
      REAL :: max_mode
      REAL :: min_mode
      REAL :: max_spreading
      REAL :: window_shift
      REAL, DIMENSION(:), ALLOCATABLE :: scale_coef
      REAL, DIMENSION(2) :: param_normalisation
      REAL, DIMENSION(:), ALLOCATABLE :: quantile
      REAL, DIMENSION(:), ALLOCATABLE :: tabulated_delay
      REAL, DIMENSION(:), ALLOCATABLE :: tabulated_spreading
      REAL, DIMENSION(:, :, :, :), ALLOCATABLE :: tabulated_routing_coef
      REAL, DIMENSION(:, :), ALLOCATABLE :: states
      REAL, DIMENSION(:, :), ALLOCATABLE :: remainder
  END TYPE TYPE_ROUTING_STATES

CONTAINS
  SUBROUTINE ROUTING_STATE_SELF_INITIALISATION(routing_setup, &
&   routing_mesh, routing_parameter, routing_states)
! Notes
! -----
! **routing_state_self_initialisation(routing_setup,routing_mesh,routing_parameter,routing_states)** :
!
! - Initialise the routing_states derived type, allocate all components and precompute some variables
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_setup``                       routing_setup Derived Type (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``routing_parameter``                   routing_parameter Derived Type (in)
! ``routing_states``                      Routing_mesh Derived Type (inout)
! =============================           ===================================
    USE MOD_GAMMA_ROUTING_SETUP
    USE MOD_GAMMA_ROUTING_MESH
USE MOD_GAMMA_ROUTING_PARAMETERS
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTEGER :: i
    REAL :: max_spreading
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
    INTRINSIC INT
    INTRINSIC MAX
    INTRINSIC MAXVAL
    INTRINSIC MINVAL
    REAL :: result1
    IF (ALLOCATED(routing_states%window_length)) THEN
      DEALLOCATE(routing_states%window_length)
    END IF
    ALLOCATE(routing_states%window_length(routing_mesh%nb_nodes))
    IF (ALLOCATED(routing_states%scale_coef)) THEN
      DEALLOCATE(routing_states%scale_coef)
    END IF
    ALLOCATE(routing_states%scale_coef(SIZE(routing_mesh%varying_dx)))
    IF (routing_setup%varying_spread) THEN
      routing_states%max_spreading = routing_setup%spreading_boundaries(&
&       2)
      routing_states%nb_spreads = INT(routing_states%max_spreading/&
&       routing_setup%spreading_discretization_step) + 1
    ELSE
      routing_states%nb_spreads = 1
      max_spreading = 0.0
      DO i=1,routing_mesh%nb_nodes
        IF (max_spreading .LT. routing_parameter%spreading(i)) THEN
          max_spreading = routing_parameter%spreading(i)
        ELSE
          max_spreading = max_spreading
        END IF
      END DO
      routing_states%max_spreading = max_spreading
    END IF
    result1 = MAXVAL(routing_mesh%dx)
    routing_states%max_mode = result1/routing_setup%vmin/routing_setup%&
&     dt
    result1 = MINVAL(routing_mesh%dx)
    routing_states%min_mode = result1/routing_setup%vmax/routing_setup%&
&     dt
    routing_states%nb_mode = INT((routing_states%max_mode+1.0)/&
&     routing_setup%mode_discretization_step) + 1
!routing_states%nb_mode=int((routing_states%max_mode-routing_states%min_mode+1.0)/routing_setup%mode_discretization_step)+1
!Condition Ã  respecter dx/dt >= 1 => courant pour v=1m/s
    IF (routing_states%max_mode .GT. routing_setup%npdt) WRITE(*, *) &
&              'Warning : npdt lower than than the maximum model delay:'&
&                                                        , routing_setup&
&                                                        %npdt, '<', &
&                                                        routing_states%&
&                                                        max_mode, &
&           'this could provoke a calibration failure or weird outputs.'
    routing_states%param_normalisation = 1.0
  END SUBROUTINE ROUTING_STATE_SELF_INITIALISATION

  SUBROUTINE ROUTING_STATES_RESET(routing_states)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
!default value
    routing_states%remainder = 0.
    routing_states%states = 0.
  END SUBROUTINE ROUTING_STATES_RESET

  SUBROUTINE ROUTING_STATES_CLEAR(routing_states)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_STATES) :: routing_states_new
    routing_states = routing_states_new
  END SUBROUTINE ROUTING_STATES_CLEAR

END MODULE MOD_GAMMA_ROUTING_STATES_DIFF_D_D_D_D_D_D

!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
MODULE MOD_GAMMA_ROUTING_DIFF_D_D_D_D_D_D
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
USE MOD_GAMMA_ROUTING_PARAMETERS
  USE MOD_GAMMA_ROUTING_STATES_DIFF_D_D_D_D_D_D
  USE MOD_GAMMA_ROUTING_RESULTS
  IMPLICIT NONE
! Creation of a local type useful for the routing model (memory) ! this is a trick for the differentiation of the model. This typ
!e need to be allocated before use: type(routing_memory), dimension(nb_nodes) : routingmem
  TYPE ROUTING_MEMORY
      REAL :: states
      REAL :: remainder
  END TYPE ROUTING_MEMORY

CONTAINS
  SUBROUTINE ROUTING_HYDROGRAM(routing_setup, routing_mesh, &
&   routing_parameter, inflows, routing_states, routing_results)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(&
&   IN) :: inflows
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_RESULTS), INTENT(INOUT) :: routing_results
    REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
&   qnetwork
    REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
&   vnetwork
    INTEGER :: i
    REAL, DIMENSION(routing_mesh%nb_nodes) :: qmesh
    REAL, DIMENSION(routing_mesh%nb_nodes) :: velocities
    REAL, DIMENSION(routing_mesh%nb_nodes) :: inflow
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes) :: routingmem
    routingmem(:, :)%states = routing_states%states
    routingmem(:, :)%remainder = routing_states%remainder
    DO i=1,routing_setup%npdt
      velocities = 0.
      qmesh = 0.
      inflow = inflows(i, 1:routing_mesh%nb_nodes)
      CALL ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter, &
&                 inflow, routing_states, routingmem, qmesh, velocities)
      qnetwork(i, :) = qmesh
      vnetwork(i, :) = velocities
    END DO
    routing_states%states = routingmem(:, :)%states
    routing_states%remainder = routingmem(:, :)%remainder
!storing results
    routing_results%discharges = qnetwork
    routing_results%velocities = vnetwork
  END SUBROUTINE ROUTING_HYDROGRAM

!  Differentiation of routing_flow in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: routingmem.states routingmem.remainder
!                qnetwork
!   with respect to varying inputs: routingmem.states routingmem.remainder
!                *(routing_parameter.hydraulics_coefficient) *(routing_parameter.spreading)
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
  SUBROUTINE ROUTING_FLOW_D(routing_setup, routing_mesh, &
&   routing_parameter, routing_parameterd, inflows, routing_states, &
&   routingmem, routingmemd, qnetwork, qnetworkd, velocities)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameterd
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(IN) :: inflows
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmemd
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: qnetwork
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: qnetworkd
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: velocities
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficientd
    REAL :: velocity
    REAL :: velocityd
    REAL :: qcell
    REAL :: qcelld
    REAL :: mode
    REAL :: moded
    INTEGER :: i
    INTEGER :: current_node
    INTEGER :: index_varying_dx
    REAL :: temp
    qnetworkd = 0.0
    DO i=1,routing_mesh%nb_nodes
!order matters
      current_node = routing_mesh%upstream_to_downstream_nodes(i)
!upstream routed discharges + inflow (m3/s)
      CALL GET_DISCHARGES_D(routing_mesh, routing_states, routingmem, &
&                     routingmemd, current_node, inflows(current_node), &
&                     qcell, qcelld)
!qnetwork is always in m3 => output discharges
      qnetworkd(current_node) = qcelld
      qnetwork(current_node) = qcell
!write(*,*) i,current_node,qcell
      CALL COMPUTE_VELOCITY_D(routing_parameter%hydraulics_coefficient(&
&                       current_node), routing_parameterd%&
&                       hydraulics_coefficient(current_node), &
&                       routing_setup, routing_mesh, routing_states, &
&                       current_node, qcell, qcelld, velocity, velocityd&
&                      )
      velocities(current_node) = velocity
      temp = routing_mesh%dx(current_node)/(routing_setup%dt*velocity)
      moded = -(temp*velocityd/velocity)
      mode = temp
      index_varying_dx = routing_mesh%index_varying_dx(current_node)
!~             write(*,*) i,qcell,velocity, mode, routing_mesh%dx(current_node),routing_setup%dt
      IF (routing_states%nb_spreads .GT. 1) THEN
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR_D(mode, moded, &
&                                                   routing_parameter%&
&                                                   spreading(&
&                                                   current_node), &
&                                                   routing_parameterd%&
&                                                   spreading(&
&                                                   current_node), &
&                                                   index_varying_dx, &
&                                                   routing_states, &
&                                                   gamma_coefficient, &
&                                                   gamma_coefficientd)
      ELSE
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR_D(mode, moded, &
&                                                 index_varying_dx, &
&                                                 routing_states, &
&                                                 gamma_coefficient, &
&                                                 gamma_coefficientd)
      END IF
!if (current_node==10) then 
!    write(*,*) velocity,mode,gamma_coefficient 
!endif
      CALL LOCALMEMSTORAGE_D(routing_mesh, routing_states, &
&                      gamma_coefficient, gamma_coefficientd, qcell, &
&                      qcelld, current_node, routingmem, routingmemd)
      CALL MEMMASSTRANSFERT_D(routing_states, routing_setup, &
&                       routing_mesh, current_node, routingmem, &
&                       routingmemd)
    END DO
  END SUBROUTINE ROUTING_FLOW_D

  SUBROUTINE ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter&
&   , inflows, routing_states, routingmem, qnetwork, velocities)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(IN) :: inflows
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: qnetwork
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: velocities
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficient
    REAL :: velocity
    REAL :: qcell
    REAL :: mode
    INTEGER :: i
    INTEGER :: current_node
    INTEGER :: index_varying_dx
    DO i=1,routing_mesh%nb_nodes
!order matters
      current_node = routing_mesh%upstream_to_downstream_nodes(i)
!upstream routed discharges + inflow (m3/s)
      CALL GET_DISCHARGES(routing_mesh, routing_states, routingmem, &
&                   current_node, inflows(current_node), qcell)
!qnetwork is always in m3 => output discharges
      qnetwork(current_node) = qcell
!write(*,*) i,current_node,qcell
      CALL COMPUTE_VELOCITY(routing_parameter%hydraulics_coefficient(&
&                     current_node), routing_setup, routing_mesh, &
&                     routing_states, current_node, qcell, velocity)
      velocities(current_node) = velocity
      mode = routing_mesh%dx(current_node)/velocity/routing_setup%dt
      index_varying_dx = routing_mesh%index_varying_dx(current_node)
!~             write(*,*) i,qcell,velocity, mode, routing_mesh%dx(current_node),routing_setup%dt
      IF (routing_states%nb_spreads .GT. 1) THEN
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR(mode, &
&                                                 routing_parameter%&
&                                                 spreading(current_node&
&                                                 ), index_varying_dx, &
&                                                 routing_states, &
&                                                 gamma_coefficient)
      ELSE
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR(mode, &
&                                               index_varying_dx, &
&                                               routing_states, &
&                                               gamma_coefficient)
      END IF
!if (current_node==10) then 
!    write(*,*) velocity,mode,gamma_coefficient 
!endif
      CALL LOCALMEMSTORAGE(routing_mesh, routing_states, &
&                    gamma_coefficient, qcell, current_node, routingmem)
      CALL MEMMASSTRANSFERT(routing_states, routing_setup, routing_mesh&
&                     , current_node, routingmem)
    END DO
  END SUBROUTINE ROUTING_FLOW

!  Differentiation of get_discharges in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: qcell
!   with respect to varying inputs: routingmem.states
!get the discharge at current node
  SUBROUTINE GET_DISCHARGES_D(routing_mesh, routing_states, routingmem, &
&   routingmemd, current_node, inflow, qcell, qcelld)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(IN) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(IN) :: routingmemd
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(IN) :: inflow
    REAL, INTENT(OUT) :: qcell
    REAL, INTENT(OUT) :: qcelld
    INTEGER :: i
    INTEGER :: upstream_node
    REAL :: qrout
    REAL :: qroutd
    qcell = 0.
    qrout = 0.
    qroutd = 0.0
    DO i=1,routing_mesh%nb_upstream_nodes
      upstream_node = routing_mesh%nodes_linker(i, current_node)
      IF (upstream_node .GT. 0) THEN
!ici on est en m3/s
        qroutd = qroutd + routingmemd(1, upstream_node)%states
        qrout = qrout + routingmem(1, upstream_node)%states
      END IF
    END DO
! en m3 
    qcelld = qroutd
    qcell = inflow + qrout
  END SUBROUTINE GET_DISCHARGES_D

!get the discharge at current node
  SUBROUTINE GET_DISCHARGES(routing_mesh, routing_states, routingmem, &
&   current_node, inflow, qcell)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(IN) :: routingmem
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(IN) :: inflow
    REAL, INTENT(OUT) :: qcell
    INTEGER :: i
    INTEGER :: upstream_node
    REAL :: qrout
    qcell = 0.
    qrout = 0.
    DO i=1,routing_mesh%nb_upstream_nodes
      upstream_node = routing_mesh%nodes_linker(i, current_node)
      IF (upstream_node .GT. 0) THEN
!ici on est en m3/s
        qrout = qrout + routingmem(1, upstream_node)%states
      END IF
    END DO
! en m3 
    qcell = inflow + qrout
  END SUBROUTINE GET_DISCHARGES

!  Differentiation of compute_velocity in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: velocity incoming_discharges
!   with respect to varying inputs: hydraulics_coefficient incoming_discharges
  SUBROUTINE COMPUTE_VELOCITY_D(hydraulics_coefficient, &
&   hydraulics_coefficientd, routing_setup, routing_mesh, routing_states&
&   , current_node, incoming_discharges, incoming_dischargesd, velocity&
&   , velocityd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: hydraulics_coefficient
    REAL, INTENT(IN) :: hydraulics_coefficientd
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(INOUT) :: incoming_discharges
    REAL, INTENT(INOUT) :: incoming_dischargesd
    REAL, INTENT(OUT) :: velocity
    REAL, INTENT(OUT) :: velocityd
    REAL :: baseflow
    REAL :: temp
    REAL :: temp0
!baseflow is mandatory, even very small, to prevent NAN computation in the adjoint code due to very very low incomming discharges
!It is not related to the velocity computation, but may be du to the spreading in memory ??
    baseflow = 0.0000001
    IF (incoming_discharges .LT. baseflow) THEN
      incoming_discharges = baseflow
      incoming_dischargesd = 0.0
    END IF
    velocity = routing_setup%vmin
    IF (routing_setup%velocity_computation .EQ. 'qmm') THEN
      temp = routing_mesh%cumulated_surface(current_node)*1000.0**2.
      temp0 = (1000.*routing_setup%dt*incoming_discharges/temp)**0.4
      velocityd = routing_states%param_normalisation(1)*(temp0*&
&       hydraulics_coefficientd+hydraulics_coefficient*0.4*(&
&       routing_setup%dt*1000.*(incoming_discharges/temp))**(-0.6)*&
&       routing_setup%dt*1000.*incoming_dischargesd/temp)
      velocity = routing_states%param_normalisation(1)*(&
&       hydraulics_coefficient*temp0)
    ELSE
      velocityd = 0.0
    END IF
    IF (routing_setup%velocity_computation .EQ. 'qm3') THEN
      temp0 = incoming_discharges**0.4
      velocityd = routing_states%param_normalisation(1)*(temp0*&
&       hydraulics_coefficientd+hydraulics_coefficient*0.4*&
&       incoming_discharges**(-0.6)*incoming_dischargesd)
      velocity = routing_states%param_normalisation(1)*(&
&       hydraulics_coefficient*temp0)
    END IF
    IF (velocity .LT. routing_setup%vmin) THEN
      velocity = routing_setup%vmin
      velocityd = 0.0
    END IF
    IF (velocity .GT. routing_setup%vmax) THEN
      velocity = routing_setup%vmax
      velocityd = 0.0
    END IF
  END SUBROUTINE COMPUTE_VELOCITY_D

  PURE SUBROUTINE COMPUTE_VELOCITY(hydraulics_coefficient, routing_setup&
&   , routing_mesh, routing_states, current_node, incoming_discharges, &
&   velocity)
    IMPLICIT NONE
    REAL, INTENT(IN) :: hydraulics_coefficient
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(INOUT) :: incoming_discharges
    REAL, INTENT(OUT) :: velocity
    REAL :: baseflow
!baseflow is mandatory, even very small, to prevent NAN computation in the adjoint code due to very very low incomming discharges
!It is not related to the velocity computation, but may be du to the spreading in memory ??
    baseflow = 0.0000001
    IF (incoming_discharges .LT. baseflow) incoming_discharges = &
&       baseflow
    velocity = routing_setup%vmin
    IF (routing_setup%velocity_computation .EQ. 'qmm') velocity = &
&       hydraulics_coefficient*routing_states%param_normalisation(1)*(&
&       incoming_discharges*routing_setup%dt*1000./(routing_mesh%&
&       cumulated_surface(current_node)*1000.0**2.))**0.4
    IF (routing_setup%velocity_computation .EQ. 'qm3') velocity = &
&       hydraulics_coefficient*routing_states%param_normalisation(1)*&
&       incoming_discharges**0.4
    IF (velocity .LT. routing_setup%vmin) velocity = routing_setup%vmin
    IF (velocity .GT. routing_setup%vmax) velocity = routing_setup%vmax
  END SUBROUTINE COMPUTE_VELOCITY

!  Differentiation of interpolated_routing_coefficients_linear in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gamma_coefficient
!   with respect to varying inputs: delay
  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR_D(delay, delayd, &
&   index_dx, routing_states, gamma_coefficient, gamma_coefficientd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: delay
    REAL, INTENT(IN) :: delayd
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficientd
    INTEGER :: i, lim_sup_ind_mu, lim_inf_ind_mu
    REAL :: delay_inf, delay_sup
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: diffcoef
    lim_inf_ind_mu = 1
    lim_sup_ind_mu = 2
!search indices
    DO i=1,routing_states%nb_mode
      IF (delay .LT. routing_states%tabulated_delay(i)) GOTO 100
    END DO
    GOTO 110
 100 lim_inf_ind_mu = i - 1
    lim_sup_ind_mu = i
 110 delay_inf = routing_states%tabulated_delay(lim_inf_ind_mu)
    delay_sup = routing_states%tabulated_delay(lim_sup_ind_mu)
!index_dx=routing_mesh%index_varying_dx(current-node)
!trick for differentiation
    diffcoef = routing_states%tabulated_routing_coef(:, lim_sup_ind_mu, &
&     1, index_dx) - routing_states%tabulated_routing_coef(:, &
&     lim_inf_ind_mu, 1, index_dx)
    gamma_coefficientd = diffcoef*delayd/(delay_sup-delay_inf)
    gamma_coefficient = routing_states%tabulated_routing_coef(:, &
&     lim_inf_ind_mu, 1, index_dx) + (delay-delay_inf)*diffcoef/(&
&     delay_sup-delay_inf)
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR_D

  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR(delay, index_dx, &
&   routing_states, gamma_coefficient)
    IMPLICIT NONE
    REAL, INTENT(IN) :: delay
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficient
    INTEGER :: i, lim_sup_ind_mu, lim_inf_ind_mu
    REAL :: delay_inf, delay_sup
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: diffcoef
    lim_inf_ind_mu = 1
    lim_sup_ind_mu = 2
!search indices
    DO i=1,routing_states%nb_mode
      IF (delay .LT. routing_states%tabulated_delay(i)) THEN
        lim_inf_ind_mu = i - 1
        lim_sup_ind_mu = i
        GOTO 100
      END IF
    END DO
 100 delay_inf = routing_states%tabulated_delay(lim_inf_ind_mu)
    delay_sup = routing_states%tabulated_delay(lim_sup_ind_mu)
!index_dx=routing_mesh%index_varying_dx(current-node)
!trick for differentiation
    diffcoef = routing_states%tabulated_routing_coef(:, lim_sup_ind_mu, &
&     1, index_dx) - routing_states%tabulated_routing_coef(:, &
&     lim_inf_ind_mu, 1, index_dx)
    gamma_coefficient = routing_states%tabulated_routing_coef(:, &
&     lim_inf_ind_mu, 1, index_dx) + (delay-delay_inf)*diffcoef/(&
&     delay_sup-delay_inf)
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR

  PURE SUBROUTINE GENERIC_INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR(delay&
&   , index_dx, window_length, nb_mode, nb_varying_dx, tabulated_delay, &
&   tabulated_gamma_coefficient, gamma_coefficient)
    IMPLICIT NONE
    REAL, INTENT(IN) :: delay
    INTEGER, INTENT(IN) :: index_dx
    INTEGER, INTENT(IN) :: window_length
    INTEGER, INTENT(IN) :: nb_mode
    INTEGER, INTENT(IN) :: nb_varying_dx
    REAL, DIMENSION(nb_mode), INTENT(IN) :: tabulated_delay
    REAL, DIMENSION(window_length, nb_mode, nb_varying_dx), INTENT(IN) &
&   :: tabulated_gamma_coefficient
    REAL, DIMENSION(window_length), INTENT(OUT) :: gamma_coefficient
    INTEGER :: i, lim_sup_ind_mu, lim_inf_ind_mu
    REAL :: delay_inf, delay_sup
    lim_inf_ind_mu = 0
    lim_sup_ind_mu = 1
!search indices
    DO i=1,nb_mode
      IF (delay .LT. tabulated_delay(i)) THEN
        lim_inf_ind_mu = i - 1
        lim_sup_ind_mu = i
        GOTO 100
      END IF
    END DO
 100 delay_inf = tabulated_delay(lim_inf_ind_mu)
    delay_sup = tabulated_delay(lim_sup_ind_mu)
    gamma_coefficient = tabulated_gamma_coefficient(:, lim_inf_ind_mu, &
&     index_dx) + (delay-delay_inf)*(tabulated_gamma_coefficient(:, &
&     lim_sup_ind_mu, index_dx)-tabulated_gamma_coefficient(:, &
&     lim_inf_ind_mu, index_dx))/(delay_sup-delay_inf)
  END SUBROUTINE GENERIC_INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR

!  Differentiation of interpolated_routing_coefficients_bilinear in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gamma_coefficient
!   with respect to varying inputs: mode spreading
  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR_D(mode, moded, &
&   spreading, spreadingd, index_dx, routing_states, gamma_coefficient, &
&   gamma_coefficientd)
    IMPLICIT NONE
    REAL, INTENT(IN) :: mode
    REAL, INTENT(IN) :: moded
    REAL, INTENT(IN) :: spreading
    REAL, INTENT(IN) :: spreadingd
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficientd
    INTEGER :: i
    INTEGER :: ix1, iy1, ix2, iy2
    REAL :: x1, y1, x2, y2
    REAL :: true_spreading
    REAL :: true_spreadingd
    REAL :: temp
    REAL :: temp0
    REAL :: temp1
    REAL :: temp2
!unormalise spreading
    true_spreadingd = routing_states%param_normalisation(2)*spreadingd
    true_spreading = spreading*routing_states%param_normalisation(2)
!index_dx=routing_mesh%index_varying_dx(current-node)
!Avoid chocs by increasing the spreading with the mode: we could calibrate the exponnent instead of the spreading... This works v
!ery well, less chocs when v is low (hydro_coef is low too)
!true_spreading=spreading*routing_states%param_normalisation(2)+spreading*routing_states%param_normalisation(2)*mode**0.5
!search indices for delay x
    ix1 = 0
    ix2 = 1
    DO i=1,routing_states%nb_mode
      IF (mode .LT. routing_states%tabulated_delay(i)) GOTO 100
    END DO
    GOTO 110
 100 ix1 = i - 1
    ix2 = i
!search indices for spreading y
 110 iy1 = 1
    iy2 = 2
    DO i=2,routing_states%nb_spreads
      IF (true_spreading .LT. routing_states%tabulated_spreading(i)) &
&       GOTO 120
    END DO
    GOTO 130
 120 iy1 = i - 1
    iy2 = i
!~         if (ix1<1) then
!~             write(*,*) mode
!~             write(*,*) routing_states%tabulated_delay
!~             stop 1
!~         end if
 130 x1 = routing_states%tabulated_delay(ix1)
    x2 = routing_states%tabulated_delay(ix2)
    y1 = routing_states%tabulated_spreading(iy1)
    y2 = routing_states%tabulated_spreading(iy2)
    temp = (x1-x2)*(y1-y2)
    temp0 = (x2-x1)*(y1-y2)
    temp1 = (x1-x2)*(y2-y1)
    temp2 = (x2-x1)*(y2-y1)
    gamma_coefficientd = routing_states%tabulated_routing_coef(:, ix1, &
&     iy1, index_dx)*((true_spreading-y2)*moded+(mode-x2)*&
&     true_spreadingd)/temp + routing_states%tabulated_routing_coef(:, &
&     ix2, iy1, index_dx)*((true_spreading-y2)*moded+(mode-x1)*&
&     true_spreadingd)/temp0 + routing_states%tabulated_routing_coef(:, &
&     ix1, iy2, index_dx)*((true_spreading-y1)*moded+(mode-x2)*&
&     true_spreadingd)/temp1 + routing_states%tabulated_routing_coef(:, &
&     ix2, iy2, index_dx)*((true_spreading-y1)*moded+(mode-x1)*&
&     true_spreadingd)/temp2
    gamma_coefficient = routing_states%tabulated_routing_coef(:, ix1, &
&     iy1, index_dx)*((mode-x2)*(true_spreading-y2)/temp) + &
&     routing_states%tabulated_routing_coef(:, ix2, iy1, index_dx)*((&
&     mode-x1)*(true_spreading-y2)/temp0) + routing_states%&
&     tabulated_routing_coef(:, ix1, iy2, index_dx)*((mode-x2)*(&
&     true_spreading-y1)/temp1) + routing_states%tabulated_routing_coef(&
&     :, ix2, iy2, index_dx)*((mode-x1)*(true_spreading-y1)/temp2)
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR_D

  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR(mode, spreading&
&   , index_dx, routing_states, gamma_coefficient)
    IMPLICIT NONE
    REAL, INTENT(IN) :: mode
    REAL, INTENT(IN) :: spreading
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficient
    INTEGER :: i
    INTEGER :: ix1, iy1, ix2, iy2
    REAL :: x1, y1, x2, y2
    REAL :: true_spreading
!unormalise spreading
    true_spreading = spreading*routing_states%param_normalisation(2)
!index_dx=routing_mesh%index_varying_dx(current-node)
!Avoid chocs by increasing the spreading with the mode: we could calibrate the exponnent instead of the spreading... This works v
!ery well, less chocs when v is low (hydro_coef is low too)
!true_spreading=spreading*routing_states%param_normalisation(2)+spreading*routing_states%param_normalisation(2)*mode**0.5
!search indices for delay x
    ix1 = 0
    ix2 = 1
    DO i=1,routing_states%nb_mode
      IF (mode .LT. routing_states%tabulated_delay(i)) THEN
        ix1 = i - 1
        ix2 = i
        GOTO 100
      END IF
    END DO
!search indices for spreading y
 100 iy1 = 1
    iy2 = 2
    DO i=2,routing_states%nb_spreads
      IF (true_spreading .LT. routing_states%tabulated_spreading(i)) &
&     THEN
        iy1 = i - 1
        iy2 = i
        GOTO 110
      END IF
    END DO
!~         if (ix1<1) then
!~             write(*,*) mode
!~             write(*,*) routing_states%tabulated_delay
!~             stop 1
!~         end if
 110 x1 = routing_states%tabulated_delay(ix1)
    x2 = routing_states%tabulated_delay(ix2)
    y1 = routing_states%tabulated_spreading(iy1)
    y2 = routing_states%tabulated_spreading(iy2)
    gamma_coefficient = (mode-x2)/(x1-x2)*((true_spreading-y2)/(y1-y2))*&
&     routing_states%tabulated_routing_coef(:, ix1, iy1, index_dx) + (&
&     mode-x1)/(x2-x1)*((true_spreading-y2)/(y1-y2))*routing_states%&
&     tabulated_routing_coef(:, ix2, iy1, index_dx) + (mode-x2)/(x1-x2)*&
&     ((true_spreading-y1)/(y2-y1))*routing_states%&
&     tabulated_routing_coef(:, ix1, iy2, index_dx) + (mode-x1)/(x2-x1)*&
&     ((true_spreading-y1)/(y2-y1))*routing_states%&
&     tabulated_routing_coef(:, ix2, iy2, index_dx)
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR

  PURE SUBROUTINE GENERIC_INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR(&
&   mode, spreading, index_dx, window_length, nb_mode, nb_spreads, &
&   nb_varying_dx, tabulated_delay, tabulated_spreading, &
&   tabulated_routing_coef, gamma_coefficient)
    IMPLICIT NONE
    REAL, INTENT(IN) :: mode
    REAL, INTENT(IN) :: spreading
    INTEGER, INTENT(IN) :: index_dx
    INTEGER, INTENT(IN) :: window_length
    INTEGER, INTENT(IN) :: nb_mode
    INTEGER, INTENT(IN) :: nb_spreads
    INTEGER, INTENT(IN) :: nb_varying_dx
    REAL, DIMENSION(nb_mode), INTENT(IN) :: tabulated_delay
    REAL, DIMENSION(nb_spreads), INTENT(IN) :: tabulated_spreading
    REAL, DIMENSION(window_length, nb_mode, nb_spreads, nb_varying_dx), &
&   INTENT(IN) :: tabulated_routing_coef
    REAL, DIMENSION(window_length), INTENT(OUT) :: gamma_coefficient
    INTEGER :: i
    INTEGER :: ix1, iy1, ix2, iy2
    REAL :: x1, y1, x2, y2
!search indices for delay x
    ix1 = 0
    ix2 = 1
    DO i=1,nb_mode
      IF (mode .LT. tabulated_delay(i)) THEN
        ix1 = i - 1
        ix2 = i
        GOTO 100
      END IF
    END DO
!search indices for spreading y
 100 iy1 = 1
    iy2 = 2
    DO i=2,nb_spreads
      IF (spreading .LT. tabulated_spreading(i)) THEN
        iy1 = i - 1
        iy2 = i
        GOTO 110
      END IF
    END DO
 110 x1 = tabulated_delay(ix1)
    x2 = tabulated_delay(ix2)
    y1 = tabulated_spreading(iy1)
    y2 = tabulated_spreading(iy2)
    gamma_coefficient = (mode-x2)/(x1-x2)*((spreading-y2)/(y1-y2))*&
&     tabulated_routing_coef(:, ix1, iy1, index_dx) + (mode-x1)/(x2-x1)*&
&     ((spreading-y2)/(y1-y2))*tabulated_routing_coef(:, ix2, iy1, &
&     index_dx) + (mode-x2)/(x1-x2)*((spreading-y1)/(y2-y1))*&
&     tabulated_routing_coef(:, ix1, iy2, index_dx) + (mode-x1)/(x2-x1)*&
&     ((spreading-y1)/(y2-y1))*tabulated_routing_coef(:, ix2, iy2, &
&     index_dx)
  END SUBROUTINE GENERIC_INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR

!  Differentiation of localmemstorage in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: routingmem.states
!   with respect to varying inputs: gamma_coefficient routingmem.states
!                qcell
!>Store and spread in memory the delayed discharge
  SUBROUTINE LOCALMEMSTORAGE_D(routing_mesh, routing_states, &
&   gamma_coefficient, gamma_coefficientd, qcell, qcelld, current_node, &
&   routingmem, routingmemd)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(IN) :: &
&   gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(IN) :: &
&   gamma_coefficientd
    REAL, INTENT(IN) :: qcell
    REAL, INTENT(IN) :: qcelld
    INTEGER, INTENT(IN) :: current_node
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmemd
    INTEGER :: t
    DO t=1,routing_states%window_length(current_node)
      routingmemd(t, current_node)%states = routingmemd(t, current_node)&
&       %states + qcell*gamma_coefficientd(t) + gamma_coefficient(t)*&
&       qcelld
      routingmem(t, current_node)%states = routingmem(t, current_node)%&
&       states + gamma_coefficient(t)*qcell
    END DO
  END SUBROUTINE LOCALMEMSTORAGE_D

!>Store and spread in memory the delayed discharge
  SUBROUTINE LOCALMEMSTORAGE(routing_mesh, routing_states, &
&   gamma_coefficient, qcell, current_node, routingmem)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(IN) :: &
&   gamma_coefficient
    REAL, INTENT(IN) :: qcell
    INTEGER, INTENT(IN) :: current_node
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    INTEGER :: t
    DO t=1,routing_states%window_length(current_node)
      routingmem(t, current_node)%states = routingmem(t, current_node)%&
&       states + gamma_coefficient(t)*qcell
    END DO
  END SUBROUTINE LOCALMEMSTORAGE

!  Differentiation of memmasstransfert in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: routingmem.states routingmem.remainder
!   with respect to varying inputs: routingmem.states routingmem.remainder
!>Switch up in time the local memory_storage array at position ix,iy
  SUBROUTINE MEMMASSTRANSFERT_D(routing_states, routing_setup, &
&   routing_mesh, current_node, routingmem, routingmemd)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    INTEGER, INTENT(IN) :: current_node
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmemd
    INTEGER :: nbmemcell
    INTEGER :: upstream_node
    INTEGER :: t
    INTEGER :: i
    REAL :: dqfill
    REAL :: dqfilld
    REAL :: inv_elongation_factor
    IF (routing_mesh%cum_node_index(current_node) .GT. 1) THEN
      inv_elongation_factor = 1./routing_setup%elongation_factor
      DO i=1,routing_mesh%nb_upstream_nodes
        upstream_node = routing_mesh%nodes_linker(i, current_node)
        IF (upstream_node .GT. 0) THEN
          nbmemcell = routing_states%window_length(upstream_node)
!loop over delay in memory
          DO t=1,nbmemcell-1
            dqfilld = inv_elongation_factor*routingmemd(t+1, &
&             upstream_node)%states
            dqfill = inv_elongation_factor*routingmem(t+1, upstream_node&
&             )%states
            routingmemd(t, upstream_node)%states = dqfilld + routingmemd&
&             (t, upstream_node)%remainder
            routingmem(t, upstream_node)%states = dqfill + routingmem(t&
&             , upstream_node)%remainder
            routingmemd(t, upstream_node)%remainder = routingmemd(t+1, &
&             upstream_node)%states - dqfilld
            routingmem(t, upstream_node)%remainder = routingmem(t+1, &
&             upstream_node)%states - dqfill
          END DO
!last time step in memory
          routingmemd(nbmemcell, upstream_node)%states = 0.0
          routingmem(nbmemcell, upstream_node)%states = 0.
          routingmemd(nbmemcell, upstream_node)%remainder = 0.0
          routingmem(nbmemcell, upstream_node)%remainder = 0.
        END IF
      END DO
    END IF
  END SUBROUTINE MEMMASSTRANSFERT_D

!>Switch up in time the local memory_storage array at position ix,iy
  PURE SUBROUTINE MEMMASSTRANSFERT(routing_states, routing_setup, &
&   routing_mesh, current_node, routingmem)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    INTEGER, INTENT(IN) :: current_node
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    INTEGER :: nbmemcell
    INTEGER :: upstream_node
    INTEGER :: t
    INTEGER :: i
    REAL :: dqfill
    REAL :: inv_elongation_factor
    IF (routing_mesh%cum_node_index(current_node) .GT. 1) THEN
      inv_elongation_factor = 1./routing_setup%elongation_factor
      DO i=1,routing_mesh%nb_upstream_nodes
        upstream_node = routing_mesh%nodes_linker(i, current_node)
        IF (upstream_node .GT. 0) THEN
          nbmemcell = routing_states%window_length(upstream_node)
!loop over delay in memory
          DO t=1,nbmemcell-1
            dqfill = inv_elongation_factor*routingmem(t+1, upstream_node&
&             )%states
            routingmem(t, upstream_node)%states = dqfill + routingmem(t&
&             , upstream_node)%remainder
            routingmem(t, upstream_node)%remainder = routingmem(t+1, &
&             upstream_node)%states - dqfill
          END DO
!last time step in memory
          routingmem(nbmemcell, upstream_node)%states = 0.
          routingmem(nbmemcell, upstream_node)%remainder = 0.
        END IF
      END DO
    END IF
  END SUBROUTINE MEMMASSTRANSFERT

END MODULE MOD_GAMMA_ROUTING_DIFF_D_D_D_D_D_D

!  Differentiation of routing_hydrogram_forward in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost
!   with respect to varying inputs: *(routing_parameter.hydraulics_coefficient)
!                *(routing_parameter.spreading)
!   RW status of diff variables: routing_parameter.hydraulics_coefficient:(loc)
!                *(routing_parameter.hydraulics_coefficient):in-killed
!                routing_parameter.spreading:(loc) *(routing_parameter.spreading):in-killed
!                cost:out
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
SUBROUTINE ROUTING_HYDROGRAM_FORWARD_D(routing_setup, routing_mesh, &
& routing_parameter, routing_parameterd, inflows, observations, &
& routing_states, routing_results, cost, costd)
! Notes
! -----
! **routing_hydrogram_forward(routing_setup,routing_mesh,routing_parameter,inflows,observations,routing_states,routing_results,co
!st)** :
!
! - Run the model an propagate the hydrogram thanks to the inflows and compute the cost function. This subroutine is differentiab
!le
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_setup``                       routing_setup Derived Type (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``routing_parameter``                   routing_parameter Derived Type (in)
! ``inflows``                             Inflows, array(npdt,nb_nodes) (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``routing_states``                      Routing_mesh Derived Type (inout)
! ``routing_results``                     Routing_results Derived Type (inout)
! ``cost``                                Cost function evaluation (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
USE MOD_GAMMA_ROUTING_PARAMETERS
  USE MOD_GAMMA_ROUTING_STATES_DIFF_D_D_D_D_D_D
  USE MOD_GAMMA_ROUTING_RESULTS
  USE MOD_GAMMA_ROUTING_DIFF_D_D_D_D_D_D
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameterd
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: inflows
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
  TYPE(TYPE_ROUTING_RESULTS), INTENT(INOUT) :: routing_results
  REAL, INTENT(OUT) :: cost
  REAL, INTENT(OUT) :: costd
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: qnetwork
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
& qnetworkd
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: vnetwork
  REAL, DIMENSION(3) :: tab_cost
  INTEGER :: i
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmesh
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmeshd
  REAL, DIMENSION(routing_mesh%nb_nodes) :: velocities
  REAL, DIMENSION(routing_mesh%nb_nodes) :: inflow
  INTRINSIC SIZE
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmem
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmemd
  IF (routing_setup%hydraulics_coef_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      routing_parameterd%hydraulics_coefficient(i) = routing_parameterd%&
&       hydraulics_coefficient(1)
      routing_parameter%hydraulics_coefficient(i) = routing_parameter%&
&       hydraulics_coefficient(1)
    END DO
  END IF
  IF (routing_setup%spreading_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      routing_parameterd%spreading(i) = routing_parameterd%spreading(1)
      routing_parameter%spreading(i) = routing_parameter%spreading(1)
    END DO
  END IF
  routingmem(:, :)%states = routing_states%states
  routingmem(:, :)%remainder = routing_states%remainder
  routingmemd%states = 0.0
  routingmemd%remainder = 0.0
  qnetworkd = 0.0
  DO i=1,routing_setup%npdt
    velocities = 0.
    qmesh = 0.
    inflow = inflows(i, 1:routing_mesh%nb_nodes)
    CALL ROUTING_FLOW_D(routing_setup, routing_mesh, routing_parameter, &
&                 routing_parameterd, inflow, routing_states, routingmem&
&                 , routingmemd, qmesh, qmeshd, velocities)
    qnetworkd(i, :) = qmeshd
    qnetwork(i, :) = qmesh
    vnetwork(i, :) = velocities
  END DO
  CALL COST_FUNCTION_D(routing_setup, routing_mesh, routing_parameter, &
&                routing_parameterd, observations, qnetwork, qnetworkd, &
&                tab_cost, cost, costd)
!storing results
  routing_results%costs = tab_cost
  routing_results%discharges = qnetwork
  routing_results%velocities = vnetwork
  routing_states%states = routingmem(:, :)%states
  routing_states%remainder = routingmem(:, :)%remainder
END SUBROUTINE ROUTING_HYDROGRAM_FORWARD_D

!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
SUBROUTINE ROUTING_HYDROGRAM_FORWARD_NODIFF_D_D_D_D_D_D(routing_setup, routing_mesh&
& , routing_parameter, inflows, observations, routing_states, &
& routing_results, cost)
! Notes
! -----
! **routing_hydrogram_forward(routing_setup,routing_mesh,routing_parameter,inflows,observations,routing_states,routing_results,co
!st)** :
!
! - Run the model an propagate the hydrogram thanks to the inflows and compute the cost function. This subroutine is differentiab
!le
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_setup``                       routing_setup Derived Type (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``routing_parameter``                   routing_parameter Derived Type (in)
! ``inflows``                             Inflows, array(npdt,nb_nodes) (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``routing_states``                      Routing_mesh Derived Type (inout)
! ``routing_results``                     Routing_results Derived Type (inout)
! ``cost``                                Cost function evaluation (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
USE MOD_GAMMA_ROUTING_PARAMETERS
  USE MOD_GAMMA_ROUTING_STATES_DIFF_D_D_D_D_D_D
  USE MOD_GAMMA_ROUTING_RESULTS
  USE MOD_GAMMA_ROUTING_DIFF_D_D_D_D_D_D
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: inflows
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
  TYPE(TYPE_ROUTING_RESULTS), INTENT(INOUT) :: routing_results
  REAL, INTENT(OUT) :: cost
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: qnetwork
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: vnetwork
  REAL, DIMENSION(3) :: tab_cost
  INTEGER :: i
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmesh
  REAL, DIMENSION(routing_mesh%nb_nodes) :: velocities
  REAL, DIMENSION(routing_mesh%nb_nodes) :: inflow
  INTRINSIC SIZE
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmem
  IF (routing_setup%hydraulics_coef_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      routing_parameter%hydraulics_coefficient(i) = routing_parameter%&
&       hydraulics_coefficient(1)
    END DO
  END IF
  IF (routing_setup%spreading_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      routing_parameter%spreading(i) = routing_parameter%spreading(1)
    END DO
  END IF
  routingmem(:, :)%states = routing_states%states
  routingmem(:, :)%remainder = routing_states%remainder
  DO i=1,routing_setup%npdt
    velocities = 0.
    qmesh = 0.
    inflow = inflows(i, 1:routing_mesh%nb_nodes)
    CALL ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter, &
&               inflow, routing_states, routingmem, qmesh, velocities)
    qnetwork(i, :) = qmesh
    vnetwork(i, :) = velocities
  END DO
  CALL COST_FUNCTION_NODIFF_D_D_D_D_D_D(routing_setup, routing_mesh, &
&                     routing_parameter, observations, qnetwork, &
&                     tab_cost, cost)
!storing results
  routing_results%costs = tab_cost
  routing_results%discharges = qnetwork
  routing_results%velocities = vnetwork
  routing_states%states = routingmem(:, :)%states
  routing_states%remainder = routingmem(:, :)%remainder
END SUBROUTINE ROUTING_HYDROGRAM_FORWARD_NODIFF_D_D_D_D_D_D

!  Differentiation of cost_function in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cost_final
!   with respect to varying inputs: *(routing_parameter.hydraulics_coefficient)
!                *(routing_parameter.spreading) qnetwork
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
!~ This file is part of GammaRouting.
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
!>costfun : Fonction cout
SUBROUTINE COST_FUNCTION_D(routing_setup, routing_mesh, &
& routing_parameter, routing_parameterd, observations, qnetwork, &
& qnetworkd, tab_cost, cost_final, cost_finald)
! Notes
! -----
! **cost_function(npdt,routing_mesh,observations,qnetwork,cost)
!
! - Compute the cost function and return the cost (roots mean square)
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``npdt``                                nimber of time-step, integer (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``qnetwork``                            Discharges in the network, array(npdt,nb_nodes) (inout)
! ``cost``                                Cost, function evaluation, real (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
USE MOD_GAMMA_ROUTING_PARAMETERS
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameterd
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: qnetwork
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: qnetworkd
  REAL, DIMENSION(3), INTENT(INOUT) :: tab_cost
  REAL, INTENT(INOUT) :: cost_final
  REAL, INTENT(INOUT) :: cost_finald
  REAL :: penalty, cost
  REAL :: penaltyd, costd
  REAL :: num, den, meanobs, sumobs
  REAL :: numd
  INTEGER :: j, i, k, numobs
  INTRINSIC TRIM
  cost = 0.
  tab_cost = 0.
  cost_final = 0.
  SELECT CASE  (TRIM(routing_setup%criteria)) 
  CASE ('rmse') 
    cost = 0.
    costd = 0.0
    DO j=1,routing_mesh%nb_nodes
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          costd = costd - 2.*(observations(i, k)-qnetwork(i, k))*&
&           qnetworkd(i, k)
          cost = cost + (observations(i, k)-qnetwork(i, k))**2.
        END DO
      END IF
    END DO
  CASE ('nse') 
    cost = 0.
    costd = 0.0
    DO j=1,routing_mesh%nb_nodes
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        sumobs = 0.
        num = 0.
        den = 0.
        numobs = 0
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          sumobs = sumobs + observations(i, k)
          numobs = numobs + 1
        END DO
        IF (numobs .GT. 0) THEN
          meanobs = sumobs/numobs
          numd = 0.0
        ELSE
          numd = 0.0
        END IF
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          numd = numd - 2.*(observations(i, k)-qnetwork(i, k))*qnetworkd&
&           (i, k)
          num = num + (observations(i, k)-qnetwork(i, k))**2.
          den = den + (observations(i, k)-meanobs)**2.
        END DO
        IF (den .GT. 0.) THEN
          costd = costd + numd/den
          cost = cost + num/den
        END IF
      END IF
    END DO
  CASE DEFAULT
    costd = 0.0
  END SELECT
  penalty = 0.
  CALL REGULARIZATION_D(routing_mesh, routing_parameter, &
&                 routing_parameterd, penalty, penaltyd)
  cost_finald = routing_setup%ponderation_cost*costd + routing_setup%&
&   ponderation_regul*penaltyd
  cost_final = routing_setup%ponderation_cost*cost + routing_setup%&
&   ponderation_regul*penalty
  tab_cost(1) = cost_final
  tab_cost(2) = cost
  tab_cost(3) = penalty
  WRITE(*, *) ''
  WRITE(*, *) '-----------------------------------------------------'
  WRITE(*, *) 'cost=', cost_final, ' ; j0=', cost, ' ; penalty=', &
& routing_setup%ponderation_regul*penalty
  WRITE(*, *) '-----------------------------------------------------'
  WRITE(*, *) ''
END SUBROUTINE COST_FUNCTION_D

!~ This file is part of GammaRouting.
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
!>costfun : Fonction cout
SUBROUTINE COST_FUNCTION_NODIFF_D_D_D_D_D_D(routing_setup, routing_mesh, &
& routing_parameter, observations, qnetwork, tab_cost, cost_final)
! Notes
! -----
! **cost_function(npdt,routing_mesh,observations,qnetwork,cost)
!
! - Compute the cost function and return the cost (roots mean square)
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``npdt``                                nimber of time-step, integer (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``qnetwork``                            Discharges in the network, array(npdt,nb_nodes) (inout)
! ``cost``                                Cost, function evaluation, real (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
USE MOD_GAMMA_ROUTING_PARAMETERS
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: qnetwork
  REAL, DIMENSION(3), INTENT(INOUT) :: tab_cost
  REAL, INTENT(INOUT) :: cost_final
  REAL :: penalty, cost
  REAL :: num, den, meanobs, sumobs
  INTEGER :: j, i, k, numobs
  INTRINSIC TRIM
  cost = 0.
  tab_cost = 0.
  cost_final = 0.
  SELECT CASE  (TRIM(routing_setup%criteria)) 
  CASE ('rmse') 
    cost = 0.
    DO j=1,routing_mesh%nb_nodes
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          cost = cost + (observations(i, k)-qnetwork(i, k))**2.
        END DO
      END IF
    END DO
  CASE ('nse') 
    cost = 0.
    DO j=1,routing_mesh%nb_nodes
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        sumobs = 0.
        num = 0.
        den = 0.
        numobs = 0
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          sumobs = sumobs + observations(i, k)
          numobs = numobs + 1
        END DO
        IF (numobs .GT. 0) meanobs = sumobs/numobs
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          num = num + (observations(i, k)-qnetwork(i, k))**2.
          den = den + (observations(i, k)-meanobs)**2.
        END DO
        IF (den .GT. 0.) cost = cost + num/den
      END IF
    END DO
  END SELECT
  penalty = 0.
  CALL REGULARIZATION_NODIFF_D_D_D_D_D_D(routing_mesh, routing_parameter, penalty)
  cost_final = routing_setup%ponderation_cost*cost + routing_setup%&
&   ponderation_regul*penalty
  tab_cost(1) = cost_final
  tab_cost(2) = cost
  tab_cost(3) = penalty
  WRITE(*, *) ''
  WRITE(*, *) '-----------------------------------------------------'
  WRITE(*, *) 'cost=', cost_final, ' ; j0=', cost, ' ; penalty=', &
& routing_setup%ponderation_regul*penalty
  WRITE(*, *) '-----------------------------------------------------'
  WRITE(*, *) ''
END SUBROUTINE COST_FUNCTION_NODIFF_D_D_D_D_D_D

!  Differentiation of regularization in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: penalty
!   with respect to varying inputs: *(routing_parameter.hydraulics_coefficient)
!                *(routing_parameter.spreading)
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
SUBROUTINE REGULARIZATION_D(routing_mesh, routing_parameter, &
& routing_parameterd, penalty, penaltyd)
USE MOD_GAMMA_ROUTING_PARAMETERS
  USE MOD_GAMMA_ROUTING_MESH
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameterd
  REAL, INTENT(INOUT) :: penalty
  REAL, INTENT(INOUT) :: penaltyd
  INTEGER :: i, current_node, next_node, previous_node
  penalty = 0.
  penaltyd = 0.0
  DO i=1,routing_mesh%nb_nodes
!order matters
    current_node = routing_mesh%upstream_to_downstream_nodes(i)
    IF (i .LT. routing_mesh%nb_nodes) THEN
      next_node = routing_mesh%upstream_to_downstream_nodes(i+1)
    ELSE
      next_node = current_node
    END IF
    IF (i .GT. 1) THEN
      previous_node = routing_mesh%upstream_to_downstream_nodes(i-1)
    ELSE
      previous_node = current_node
    END IF
    penaltyd = penaltyd + 0.5*2.*((routing_parameter%&
&     hydraulics_coefficient(current_node)-routing_parameter%&
&     hydraulics_coefficient(previous_node))**2.-(routing_parameter%&
&     hydraulics_coefficient(current_node)-routing_parameter%&
&     hydraulics_coefficient(next_node))**2.)*(2.*(routing_parameter%&
&     hydraulics_coefficient(current_node)-routing_parameter%&
&     hydraulics_coefficient(previous_node))*(routing_parameterd%&
&     hydraulics_coefficient(current_node)-routing_parameterd%&
&     hydraulics_coefficient(previous_node))-2.*(routing_parameter%&
&     hydraulics_coefficient(current_node)-routing_parameter%&
&     hydraulics_coefficient(next_node))*(routing_parameterd%&
&     hydraulics_coefficient(current_node)-routing_parameterd%&
&     hydraulics_coefficient(next_node)))
    penalty = penalty + 0.5*((routing_parameter%hydraulics_coefficient(&
&     current_node)-routing_parameter%hydraulics_coefficient(&
&     previous_node))**2.-(routing_parameter%hydraulics_coefficient(&
&     current_node)-routing_parameter%hydraulics_coefficient(next_node))&
&     **2.)**2.
    penaltyd = penaltyd + 0.5*2.*((routing_parameter%spreading(&
&     current_node)-routing_parameter%spreading(previous_node))**2.-(&
&     routing_parameter%spreading(current_node)-routing_parameter%&
&     spreading(next_node))**2.)*(2.*(routing_parameter%spreading(&
&     current_node)-routing_parameter%spreading(previous_node))*(&
&     routing_parameterd%spreading(current_node)-routing_parameterd%&
&     spreading(previous_node))-2.*(routing_parameter%spreading(&
&     current_node)-routing_parameter%spreading(next_node))*(&
&     routing_parameterd%spreading(current_node)-routing_parameterd%&
&     spreading(next_node)))
    penalty = penalty + 0.5*((routing_parameter%spreading(current_node)-&
&     routing_parameter%spreading(previous_node))**2.-(routing_parameter&
&     %spreading(current_node)-routing_parameter%spreading(next_node))**&
&     2.)**2.
  END DO
END SUBROUTINE REGULARIZATION_D

SUBROUTINE REGULARIZATION_NODIFF_D_D_D_D_D_D(routing_mesh, routing_parameter, &
& penalty)
USE MOD_GAMMA_ROUTING_PARAMETERS
  USE MOD_GAMMA_ROUTING_MESH
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  REAL, INTENT(INOUT) :: penalty
  INTEGER :: i, current_node, next_node, previous_node
  penalty = 0.
  DO i=1,routing_mesh%nb_nodes
!order matters
    current_node = routing_mesh%upstream_to_downstream_nodes(i)
    IF (i .LT. routing_mesh%nb_nodes) THEN
      next_node = routing_mesh%upstream_to_downstream_nodes(i+1)
    ELSE
      next_node = current_node
    END IF
    IF (i .GT. 1) THEN
      previous_node = routing_mesh%upstream_to_downstream_nodes(i-1)
    ELSE
      previous_node = current_node
    END IF
    penalty = penalty + 0.5*((routing_parameter%hydraulics_coefficient(&
&     current_node)-routing_parameter%hydraulics_coefficient(&
&     previous_node))**2.-(routing_parameter%hydraulics_coefficient(&
&     current_node)-routing_parameter%hydraulics_coefficient(next_node))&
&     **2.)**2.
    penalty = penalty + 0.5*((routing_parameter%spreading(current_node)-&
&     routing_parameter%spreading(previous_node))**2.-(routing_parameter&
&     %spreading(current_node)-routing_parameter%spreading(next_node))**&
&     2.)**2.
  END DO
END SUBROUTINE REGULARIZATION_NODIFF_D_D_D_D_D_D

