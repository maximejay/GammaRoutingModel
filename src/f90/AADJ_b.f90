!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
MODULE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  IMPLICIT NONE
! damping coefficient in seconds (s/m): spreading of the Gamma law
  TYPE TYPE_ROUTING_PARAMETER
      REAL, DIMENSION(:), ALLOCATABLE :: hydraulics_coefficient
      REAL, DIMENSION(:), ALLOCATABLE :: spreading
      INTEGER :: normalized
  END TYPE TYPE_ROUTING_PARAMETER
  TYPE TYPE_ROUTING_PARAMETER_DIFF
      REAL, DIMENSION(:), ALLOCATABLE :: hydraulics_coefficient
      REAL, DIMENSION(:), ALLOCATABLE :: spreading
  END TYPE TYPE_ROUTING_PARAMETER_DIFF

CONTAINS
  SUBROUTINE ROUTING_PARAMETER_SELF_INITIALISATION(routing_parameter, &
&   routing_setup, routing_mesh, hydraulics_coefficient, spreading)
! Notes
! -----
! **routing_parameter_self_initialisation(routing_parameter,routing_setup,routing_mesh,hydraulics_coefficient,spreading)** :
!
! - Initialise the routing_parameter derived type with user values, allocate all components and set user values for all nodes
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_parameter``                   routing_parameter Derived Type (inout)
! ``routing_setup``                       routing_setup Derived Type (inout)
! ``routing_mesh``                        Routing_mesh Derived Type (inout)
! ``hydraulics_coefficient=1.``           Value of the hydraulic coefficient (optional)
! ``spreading=dt./dx.``                   Value of the spreading coefficient, default is set to dt (in second/m)(optional)
! =============================           ===================================
    USE MOD_GAMMA_ROUTING_SETUP
    USE MOD_GAMMA_ROUTING_MESH
    IMPLICIT NONE
!reading parameter
!setting parameter
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    REAL, OPTIONAL, INTENT(IN) :: hydraulics_coefficient
    REAL, OPTIONAL, INTENT(IN) :: spreading
    INTEGER :: i
    INTRINSIC ALLOCATED
    INTRINSIC PRESENT
    IF (.NOT.ALLOCATED(routing_parameter%hydraulics_coefficient)) THEN
      ALLOCATE(routing_parameter%hydraulics_coefficient(routing_mesh%&
&     nb_nodes))
    END IF
    IF (.NOT.ALLOCATED(routing_parameter%spreading)) THEN
      ALLOCATE(routing_parameter%spreading(routing_mesh%nb_nodes))
    END IF
    IF (PRESENT(hydraulics_coefficient) .AND. hydraulics_coefficient &
&       .GT. 0.0) THEN
      routing_parameter%hydraulics_coefficient = hydraulics_coefficient
    ELSE
!default value
      routing_parameter%hydraulics_coefficient = 1.0
    END IF
    IF (PRESENT(spreading) .AND. spreading .GT. 0.0) THEN
! given in s/m 
      routing_parameter%spreading = spreading
    ELSE
      DO i=1,routing_mesh%nb_nodes
!default value
        routing_parameter%spreading(i) = routing_setup%dt/routing_mesh%&
&         dx(i)
      END DO
    END IF
    routing_parameter%normalized = 0
  END SUBROUTINE ROUTING_PARAMETER_SELF_INITIALISATION

  SUBROUTINE ROUTING_PARAMETER_CLEAR(routing_parameter)
    IMPLICIT NONE
! Notes
! -----
! **routing_parameter_clear(routing_parameter)** :
!
! - Clear the derived type routing_parameter
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_parameter``                   routing_parameter Derived Type (inout)
! =============================           ===================================
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
    TYPE(TYPE_ROUTING_PARAMETER) :: routing_parameter_new
    routing_parameter = routing_parameter_new
  END SUBROUTINE ROUTING_PARAMETER_CLEAR

  SUBROUTINE ROUTING_PARAMETER_COPY(routing_parameter, object_copy)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(OUT) :: object_copy
    object_copy = routing_parameter
  END SUBROUTINE ROUTING_PARAMETER_COPY

END MODULE MOD_GAMMA_ROUTING_PARAMETERS_DIFF

!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
MODULE MOD_GAMMA_ROUTING_STATES_DIFF
  IMPLICIT NONE
! length of the delay windows (model memory)
!number of discretization mode
!number of discretization spreads
!the highest mode i.e for vmin and dx max
!the lowest mode i.e for vmax and dx min
!the highest spreading values in s/m
!shift so that the peak of the PDF is located at x=dmin/vmax
!real :: max_scale !uniform scale coefficient computed thanks to the max_spread coeff
!non uniform scale coefficient computed thanks to the max_spread coeff
!Array of factor to normaize the model parameters (hydraulic_coeff, spreading)
!quantiles series to compute the Gamma pdf/cdf 
!tabulated delay (or mode) to locate the Gamma pdf
!tabulated spreading to spread the Gamma pdf
!real,dimension(:,:,:), allocatable :: tabulated_routing_coef !tabulated routing coefficient for the unit hydrogram
!tabulated routing coefficient for the unit hydrogram
!state of the system at t0
!remainder for the routing scheme
  TYPE TYPE_ROUTING_STATES
      INTEGER, DIMENSION(:), ALLOCATABLE :: window_length
      INTEGER :: nb_mode
      INTEGER :: nb_spreads
      REAL :: max_mode
      REAL :: min_mode
      REAL :: max_spreading
      REAL :: window_shift
      REAL, DIMENSION(:), ALLOCATABLE :: scale_coef
      REAL, DIMENSION(2) :: param_normalisation
      REAL, DIMENSION(:), ALLOCATABLE :: quantile
      REAL, DIMENSION(:), ALLOCATABLE :: tabulated_delay
      REAL, DIMENSION(:), ALLOCATABLE :: tabulated_spreading
      REAL, DIMENSION(:, :, :, :), ALLOCATABLE :: tabulated_routing_coef
      REAL, DIMENSION(:, :), ALLOCATABLE :: states
      REAL, DIMENSION(:, :), ALLOCATABLE :: remainder
  END TYPE TYPE_ROUTING_STATES

CONTAINS
  SUBROUTINE ROUTING_STATE_SELF_INITIALISATION(routing_setup, &
&   routing_mesh, routing_parameter, routing_states)
! Notes
! -----
! **routing_state_self_initialisation(routing_setup,routing_mesh,routing_parameter,routing_states)** :
!
! - Initialise the routing_states derived type, allocate all components and precompute some variables
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_setup``                       routing_setup Derived Type (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``routing_parameter``                   routing_parameter Derived Type (in)
! ``routing_states``                      Routing_mesh Derived Type (inout)
! =============================           ===================================
    USE MOD_GAMMA_ROUTING_SETUP
    USE MOD_GAMMA_ROUTING_MESH
    USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTEGER :: i
    REAL :: max_spreading
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
    INTRINSIC INT
    INTRINSIC MAXVAL
    INTRINSIC MINVAL
    REAL :: result1
    IF (ALLOCATED(routing_states%window_length)) THEN
      DEALLOCATE(routing_states%window_length)
    END IF
    ALLOCATE(routing_states%window_length(routing_mesh%nb_nodes))
    IF (ALLOCATED(routing_states%scale_coef)) THEN
      DEALLOCATE(routing_states%scale_coef)
    END IF
    ALLOCATE(routing_states%scale_coef(SIZE(routing_mesh%varying_dx)))
    IF (routing_setup%varying_spread .GT. 0) THEN
      routing_states%max_spreading = routing_setup%spreading_boundaries(&
&       2)
      routing_states%nb_spreads = INT(routing_states%max_spreading/&
&       routing_setup%spreading_discretization_step) + 1
    ELSE
      routing_states%nb_spreads = 1
!~             max_spreading=0.0
!~             max_spreading=maxval(routing_parameter%spreading)
!~             do i=1,routing_mesh%nb_nodes
!~                 max_spreading=max(max_spreading,routing_parameter%spreading(i))
!~             end do
!~             routing_states%max_spreading=max_spreading
      routing_states%max_spreading = MAXVAL(routing_parameter%spreading)
!~             routing_states%max_spreading=routing_setup%spreading_boundaries(2)
    END IF
    result1 = MAXVAL(routing_mesh%dx)
    routing_states%max_mode = result1/routing_setup%vmin/routing_setup%&
&     dt
    result1 = MINVAL(routing_mesh%dx)
    routing_states%min_mode = result1/routing_setup%vmax/routing_setup%&
&     dt
    routing_states%nb_mode = INT((routing_states%max_mode+1.0)/&
&     routing_setup%mode_discretization_step) + 1
!routing_states%nb_mode=int((routing_states%max_mode-routing_states%min_mode+1.0)/routing_setup%mode_discretization_step)+1
!Condition Ã  respecter dx/dt >= 1 => courant pour v=1m/s
    IF (routing_states%max_mode .GT. routing_setup%npdt) WRITE(*, *) &
&              'Warning : npdt lower than than the maximum model delay:'&
&                                                        , routing_setup&
&                                                        %npdt, '<', &
&                                                        routing_states%&
&                                                        max_mode, &
&           'this could provoke a calibration failure or weird outputs.'
    routing_states%param_normalisation = 1.0
  END SUBROUTINE ROUTING_STATE_SELF_INITIALISATION

  SUBROUTINE ROUTING_STATES_RESET(routing_states)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
!default value
    routing_states%remainder = 0.
    routing_states%states = 0.
  END SUBROUTINE ROUTING_STATES_RESET

  SUBROUTINE ROUTING_STATES_CLEAR(routing_states)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_STATES) :: routing_states_new
    routing_states = routing_states_new
  END SUBROUTINE ROUTING_STATES_CLEAR

  SUBROUTINE ROUTING_STATES_COPY(routing_states, object_copy)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    TYPE(TYPE_ROUTING_STATES), INTENT(OUT) :: object_copy
    object_copy = routing_states
  END SUBROUTINE ROUTING_STATES_COPY

END MODULE MOD_GAMMA_ROUTING_STATES_DIFF

!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
MODULE MOD_GAMMA_ROUTING_DIFF
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  USE MOD_GAMMA_ROUTING_STATES_DIFF
  USE MOD_GAMMA_ROUTING_RESULTS
  IMPLICIT NONE
! Creation of a local type useful for the routing model (memory) ! this is a trick for the differentiation of the model. This typ
!e need to be allocated before use: type(routing_memory), dimension(nb_nodes) : routingmem
  TYPE ROUTING_MEMORY
      REAL :: states
      REAL :: remainder
  END TYPE ROUTING_MEMORY

CONTAINS
!  Differentiation of x_unn in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: x x_unn
!   with respect to varying inputs: x
  SUBROUTINE X_UNN_B(flag, lb, ub, x, xb, x_unnb)
    IMPLICIT NONE
    INTEGER :: flag
    REAL :: x_unn
    REAL :: x_unnb
    REAL, INTENT(IN) :: lb
    REAL, INTENT(IN) :: ub
    REAL, INTENT(IN) :: x
    REAL :: xb
    IF (flag .EQ. 1) THEN
      xb = xb + (ub-lb)*x_unnb
    ELSE
      xb = xb + x_unnb
    END IF
  END SUBROUTINE X_UNN_B

  FUNCTION X_UNN(flag, lb, ub, x)
    IMPLICIT NONE
    INTEGER :: flag
    REAL :: x_unn
    REAL, INTENT(IN) :: lb
    REAL, INTENT(IN) :: ub
    REAL, INTENT(IN) :: x
    IF (flag .EQ. 1) THEN
      x_unn = x*(ub-lb) + lb
    ELSE
      x_unn = x
    END IF
  END FUNCTION X_UNN

  SUBROUTINE ROUTING_HYDROGRAM(routing_setup, routing_mesh, &
&   routing_parameter, inflows, routing_states, routing_results)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(&
&   IN) :: inflows
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_RESULTS), INTENT(INOUT) :: routing_results
    REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
&   qnetwork
    REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
&   vnetwork
    INTEGER :: i
    REAL, DIMENSION(routing_mesh%nb_nodes) :: qmesh
    REAL, DIMENSION(routing_mesh%nb_nodes) :: velocities
    REAL, DIMENSION(routing_mesh%nb_nodes) :: inflow
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes) :: routingmem
    routingmem(:, :)%states = routing_states%states
    routingmem(:, :)%remainder = routing_states%remainder
    DO i=1,routing_setup%npdt
      velocities = 0.
      qmesh = 0.
      inflow = inflows(i, 1:routing_mesh%nb_nodes)
      CALL ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter, &
&                 inflow, routing_states, routingmem, qmesh, velocities)
      qnetwork(i, :) = qmesh
      vnetwork(i, :) = velocities
    END DO
    routing_states%states = routingmem(:, :)%states
    routing_states%remainder = routingmem(:, :)%remainder
!storing results
    routing_results%discharges = qnetwork
    routing_results%velocities = vnetwork
  END SUBROUTINE ROUTING_HYDROGRAM

!  Differentiation of routing_flow in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: routingmem.states routingmem.remainder
!                *(routing_parameter.hydraulics_coefficient) *(routing_parameter.spreading)
!                qnetwork
!   with respect to varying inputs: routingmem.states routingmem.remainder
!                inflows *(routing_parameter.hydraulics_coefficient)
!                *(routing_parameter.spreading)
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
  SUBROUTINE ROUTING_FLOW_B(routing_setup, routing_mesh, &
&   routing_parameter, routing_parameterb, inflows, inflowsb, &
&   routing_states, routingmem, routingmemb, qnetwork, qnetworkb, &
&   velocities)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    TYPE(TYPE_ROUTING_PARAMETER_DIFF) :: routing_parameterb
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(IN) :: inflows
    REAL, DIMENSION(routing_mesh%nb_nodes) :: inflowsb
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmemb
    REAL, DIMENSION(routing_mesh%nb_nodes) :: qnetwork
    REAL, DIMENSION(routing_mesh%nb_nodes) :: qnetworkb
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: velocities
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficientb
    REAL :: velocity
    REAL :: velocityb
    REAL :: qcell
    REAL :: qcellb
    REAL :: mode
    REAL :: modeb
    REAL :: hydro_param_unn, spreading_unn
    REAL :: hydro_param_unnb, spreading_unnb
    INTEGER :: i
    INTEGER :: current_node
    INTEGER :: index_varying_dx
    INTEGER :: branch
    DO i=1,routing_mesh%nb_nodes
!order matters
      current_node = routing_mesh%upstream_to_downstream_nodes(i)
!upstream routed discharges + inflow (m3/s)
      CALL PUSHREAL4(qcell)
      CALL GET_DISCHARGES(routing_mesh, routing_states, routingmem, &
&                   current_node, inflows(current_node), qcell)
!qnetwork is always in m3 => output discharges
!write(*,*) i,current_node,qcell
      CALL PUSHREAL4(hydro_param_unn)
      hydro_param_unn = X_UNN(routing_parameter%normalized, &
&       routing_setup%hydrau_coef_boundaries(1), routing_setup%&
&       hydrau_coef_boundaries(2), routing_parameter%&
&       hydraulics_coefficient(current_node))
      CALL PUSHREAL4(velocity)
      CALL PUSHREAL4(qcell)
      CALL COMPUTE_VELOCITY(hydro_param_unn, routing_setup, routing_mesh&
&                     , routing_states, current_node, qcell, velocity)
      mode = routing_mesh%dx(current_node)/velocity/routing_setup%dt
      index_varying_dx = routing_mesh%index_varying_dx(current_node)
!~             write(*,*) i,qcell,velocity, mode, routing_mesh%dx(current_node),routing_setup%dt
      IF (routing_setup%varying_spread .EQ. 1) THEN
        CALL PUSHREAL4(spreading_unn)
        spreading_unn = X_UNN(routing_parameter%normalized, &
&         routing_setup%spreading_boundaries(1), routing_setup%&
&         spreading_boundaries(2), routing_parameter%spreading(&
&         current_node))
        CALL PUSHREAL4ARRAY(gamma_coefficient, SIZE(routing_states%&
&                     quantile))
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR(mode, &
&                                                 spreading_unn, &
&                                                 index_varying_dx, &
&                                                 routing_states, &
&                                                 gamma_coefficient)
!~                 call interpolated_routing_coefficients_bicubic(mode,spreading_unn,&
!~                 &index_varying_dx,routing_states,gamma_coefficient)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL4ARRAY(gamma_coefficient, SIZE(routing_states%&
&                     quantile))
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR(mode, &
&                                               index_varying_dx, &
&                                               routing_states, &
&                                               gamma_coefficient)
        CALL PUSHCONTROL1B(1)
      END IF
!if (current_node==10) then 
!    write(*,*) velocity,mode,gamma_coefficient 
!endif
      CALL LOCALMEMSTORAGE(routing_mesh, routing_states, &
&                    gamma_coefficient, qcell, current_node, routingmem)
      CALL MEMMASSTRANSFERT(routing_states, routing_setup, routing_mesh&
&                     , current_node, routingmem)
    END DO
    inflowsb = 0.0
    DO i=routing_mesh%nb_nodes,1,-1
      current_node = routing_mesh%upstream_to_downstream_nodes(i)
      CALL MEMMASSTRANSFERT_B(routing_states, routing_setup, &
&                       routing_mesh, current_node, routingmem, &
&                       routingmemb)
      CALL LOCALMEMSTORAGE_B(routing_mesh, routing_states, &
&                      gamma_coefficient, gamma_coefficientb, qcell, &
&                      qcellb, current_node, routingmem, routingmemb)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        index_varying_dx = routing_mesh%index_varying_dx(current_node)
        mode = routing_mesh%dx(current_node)/velocity/routing_setup%dt
        CALL POPREAL4ARRAY(gamma_coefficient, SIZE(routing_states%&
&                    quantile))
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR_B(mode, modeb, &
&                                                   spreading_unn, &
&                                                   spreading_unnb, &
&                                                   index_varying_dx, &
&                                                   routing_states, &
&                                                   gamma_coefficient, &
&                                                   gamma_coefficientb)
        CALL POPREAL4(spreading_unn)
        CALL X_UNN_B(routing_parameter%normalized, routing_setup%&
&              spreading_boundaries(1), routing_setup%&
&              spreading_boundaries(2), routing_parameter%spreading(&
&              current_node), routing_parameterb%spreading(current_node)&
&              , spreading_unnb)
      ELSE
        index_varying_dx = routing_mesh%index_varying_dx(current_node)
        mode = routing_mesh%dx(current_node)/velocity/routing_setup%dt
        CALL POPREAL4ARRAY(gamma_coefficient, SIZE(routing_states%&
&                    quantile))
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR_B(mode, modeb, &
&                                                 index_varying_dx, &
&                                                 routing_states, &
&                                                 gamma_coefficient, &
&                                                 gamma_coefficientb)
      END IF
      velocityb = -(routing_mesh%dx(current_node)*modeb/(velocity**2*&
&       routing_setup%dt))
      CALL POPREAL4(qcell)
      CALL POPREAL4(velocity)
      CALL COMPUTE_VELOCITY_B(hydro_param_unn, hydro_param_unnb, &
&                       routing_setup, routing_mesh, routing_states, &
&                       current_node, qcell, qcellb, velocity, velocityb&
&                      )
      CALL POPREAL4(hydro_param_unn)
      CALL X_UNN_B(routing_parameter%normalized, routing_setup%&
&            hydrau_coef_boundaries(1), routing_setup%&
&            hydrau_coef_boundaries(2), routing_parameter%&
&            hydraulics_coefficient(current_node), routing_parameterb%&
&            hydraulics_coefficient(current_node), hydro_param_unnb)
      qcellb = qcellb + qnetworkb(current_node)
      qnetworkb(current_node) = 0.0
      CALL POPREAL4(qcell)
      CALL GET_DISCHARGES_B(routing_mesh, routing_states, routingmem, &
&                     routingmemb, current_node, inflows(current_node), &
&                     inflowsb(current_node), qcell, qcellb)
    END DO
  END SUBROUTINE ROUTING_FLOW_B

  SUBROUTINE ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter&
&   , inflows, routing_states, routingmem, qnetwork, velocities)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(IN) :: inflows
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: qnetwork
    REAL, DIMENSION(routing_mesh%nb_nodes), INTENT(OUT) :: velocities
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficient
    REAL :: velocity
    REAL :: qcell
    REAL :: mode
    REAL :: hydro_param_unn, spreading_unn
    INTEGER :: i
    INTEGER :: current_node
    INTEGER :: index_varying_dx
    DO i=1,routing_mesh%nb_nodes
!order matters
      current_node = routing_mesh%upstream_to_downstream_nodes(i)
!upstream routed discharges + inflow (m3/s)
      CALL GET_DISCHARGES(routing_mesh, routing_states, routingmem, &
&                   current_node, inflows(current_node), qcell)
!qnetwork is always in m3 => output discharges
      qnetwork(current_node) = qcell
!write(*,*) i,current_node,qcell
      hydro_param_unn = X_UNN(routing_parameter%normalized, &
&       routing_setup%hydrau_coef_boundaries(1), routing_setup%&
&       hydrau_coef_boundaries(2), routing_parameter%&
&       hydraulics_coefficient(current_node))
      CALL COMPUTE_VELOCITY(hydro_param_unn, routing_setup, routing_mesh&
&                     , routing_states, current_node, qcell, velocity)
      velocities(current_node) = velocity
      mode = routing_mesh%dx(current_node)/velocity/routing_setup%dt
      index_varying_dx = routing_mesh%index_varying_dx(current_node)
!~             write(*,*) i,qcell,velocity, mode, routing_mesh%dx(current_node),routing_setup%dt
      IF (routing_setup%varying_spread .EQ. 1) THEN
        spreading_unn = X_UNN(routing_parameter%normalized, &
&         routing_setup%spreading_boundaries(1), routing_setup%&
&         spreading_boundaries(2), routing_parameter%spreading(&
&         current_node))
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR(mode, &
&                                                 spreading_unn, &
&                                                 index_varying_dx, &
&                                                 routing_states, &
&                                                 gamma_coefficient)
!~                 call interpolated_routing_coefficients_bicubic(mode,spreading_unn,&
!~                 &index_varying_dx,routing_states,gamma_coefficient)
      ELSE
        CALL INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR(mode, &
&                                               index_varying_dx, &
&                                               routing_states, &
&                                               gamma_coefficient)
      END IF
!if (current_node==10) then 
!    write(*,*) velocity,mode,gamma_coefficient 
!endif
      CALL LOCALMEMSTORAGE(routing_mesh, routing_states, &
&                    gamma_coefficient, qcell, current_node, routingmem)
      CALL MEMMASSTRANSFERT(routing_states, routing_setup, routing_mesh&
&                     , current_node, routingmem)
    END DO
  END SUBROUTINE ROUTING_FLOW

!  Differentiation of get_discharges in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: routingmem.states qcell inflow
!   with respect to varying inputs: routingmem.states inflow
!get the discharge at current node
  SUBROUTINE GET_DISCHARGES_B(routing_mesh, routing_states, routingmem, &
&   routingmemb, current_node, inflow, inflowb, qcell, qcellb)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(IN) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes) :: routingmemb
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(IN) :: inflow
    REAL :: inflowb
    REAL :: qcell
    REAL :: qcellb
    INTEGER :: i
    INTEGER :: upstream_node
    REAL :: qrout
    REAL :: qroutb
    INTEGER :: branch
    DO i=1,routing_mesh%nb_upstream_nodes
      upstream_node = routing_mesh%nodes_linker(i, current_node)
      IF (upstream_node .GT. 0) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    inflowb = inflowb + qcellb
    qroutb = qcellb
    DO i=routing_mesh%nb_upstream_nodes,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        upstream_node = routing_mesh%nodes_linker(i, current_node)
        routingmemb(1, upstream_node)%states = routingmemb(1, &
&         upstream_node)%states + qroutb
      END IF
    END DO
  END SUBROUTINE GET_DISCHARGES_B

!get the discharge at current node
  SUBROUTINE GET_DISCHARGES(routing_mesh, routing_states, routingmem, &
&   current_node, inflow, qcell)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(IN) :: routingmem
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(IN) :: inflow
    REAL, INTENT(OUT) :: qcell
    INTEGER :: i
    INTEGER :: upstream_node
    REAL :: qrout
    qcell = 0.
    qrout = 0.
    DO i=1,routing_mesh%nb_upstream_nodes
      upstream_node = routing_mesh%nodes_linker(i, current_node)
      IF (upstream_node .GT. 0) THEN
!ici on est en m3/s
        qrout = qrout + routingmem(1, upstream_node)%states
      END IF
    END DO
! en m3 
    qcell = inflow + qrout
  END SUBROUTINE GET_DISCHARGES

!  Differentiation of compute_velocity in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: velocity incoming_discharges
!   with respect to varying inputs: hydraulics_coefficient incoming_discharges
  SUBROUTINE COMPUTE_VELOCITY_B(hydraulics_coefficient, &
&   hydraulics_coefficientb, routing_setup, routing_mesh, routing_states&
&   , current_node, incoming_discharges, incoming_dischargesb, velocity&
&   , velocityb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: hydraulics_coefficient
    REAL :: hydraulics_coefficientb
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(INOUT) :: incoming_discharges
    REAL, INTENT(INOUT) :: incoming_dischargesb
    REAL :: velocity
    REAL :: velocityb
    REAL :: baseflow
    REAL :: temp
    REAL :: temp0
    INTEGER :: branch
!baseflow is mandatory, even very small, to prevent NAN computation in the adjoint code due to very very low incomming discharges
!It is not related to the velocity computation, but may be du to the spreading in memory ??
    baseflow = 0.0000001
    IF (incoming_discharges .LT. baseflow) THEN
      incoming_discharges = baseflow
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(velocity)
    velocity = routing_setup%vmax
    IF (routing_setup%velocity_computation .EQ. 'qmm') THEN
      velocity = hydraulics_coefficient*(incoming_discharges*&
&       routing_setup%dt*1000./(routing_mesh%cumulated_surface(&
&       current_node)*1000.0**2.))**0.4
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (routing_setup%velocity_computation .EQ. 'qm3') THEN
      velocity = hydraulics_coefficient*incoming_discharges**0.4
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (velocity .LT. routing_setup%vmin) THEN
      velocity = routing_setup%vmin
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (velocity .GT. routing_setup%vmax) velocityb = 0.0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) velocityb = 0.0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      hydraulics_coefficientb = incoming_discharges**0.4*velocityb
      incoming_dischargesb = incoming_dischargesb + 0.4*&
&       incoming_discharges**(-0.6)*hydraulics_coefficient*velocityb
      velocityb = 0.0
    ELSE
      hydraulics_coefficientb = 0.0
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp = routing_mesh%cumulated_surface(current_node)*1000.0**2.
      temp0 = 1000.*routing_setup%dt*incoming_discharges/temp
      hydraulics_coefficientb = hydraulics_coefficientb + temp0**0.4*&
&       velocityb
      incoming_dischargesb = incoming_dischargesb + routing_setup%dt*&
&       1000.*0.4*temp0**(-0.6)*hydraulics_coefficient*velocityb/temp
    END IF
    CALL POPREAL4(velocity)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) incoming_dischargesb = 0.0
  END SUBROUTINE COMPUTE_VELOCITY_B

  PURE SUBROUTINE COMPUTE_VELOCITY(hydraulics_coefficient, routing_setup&
&   , routing_mesh, routing_states, current_node, incoming_discharges, &
&   velocity)
    IMPLICIT NONE
    REAL, INTENT(IN) :: hydraulics_coefficient
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTEGER, INTENT(IN) :: current_node
    REAL, INTENT(INOUT) :: incoming_discharges
    REAL, INTENT(OUT) :: velocity
    REAL :: baseflow
!baseflow is mandatory, even very small, to prevent NAN computation in the adjoint code due to very very low incomming discharges
!It is not related to the velocity computation, but may be du to the spreading in memory ??
    baseflow = 0.0000001
    IF (incoming_discharges .LT. baseflow) incoming_discharges = &
&       baseflow
    velocity = routing_setup%vmax
    IF (routing_setup%velocity_computation .EQ. 'qmm') velocity = &
&       hydraulics_coefficient*(incoming_discharges*routing_setup%dt*&
&       1000./(routing_mesh%cumulated_surface(current_node)*1000.0**2.))&
&       **0.4
    IF (routing_setup%velocity_computation .EQ. 'qm3') velocity = &
&       hydraulics_coefficient*incoming_discharges**0.4
    IF (velocity .LT. routing_setup%vmin) velocity = routing_setup%vmin
    IF (velocity .GT. routing_setup%vmax) velocity = routing_setup%vmax
  END SUBROUTINE COMPUTE_VELOCITY

!  Differentiation of interpolated_routing_coefficients_linear in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: gamma_coefficient
!   with respect to varying inputs: delay
  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR_B(delay, delayb, &
&   index_dx, routing_states, gamma_coefficient, gamma_coefficientb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: delay
    REAL :: delayb
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficientb
    INTEGER :: i, lim_sup_ind_mu, lim_inf_ind_mu
    REAL :: delay_inf, delay_sup
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: diffcoef
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
    lim_inf_ind_mu = 1
    lim_sup_ind_mu = 2
    ad_count = 1
!search indices
    DO i=1,routing_states%nb_mode
      IF (delay .LT. routing_states%tabulated_delay(i)) THEN
        GOTO 100
      ELSE
        ad_count = ad_count + 1
      END IF
    END DO
    CALL PUSHCONTROL1B(0)
    CALL PUSHINTEGER4(ad_count)
    GOTO 110
 100 CALL PUSHCONTROL1B(1)
    CALL PUSHINTEGER4(ad_count)
    lim_inf_ind_mu = i - 1
    lim_sup_ind_mu = i
 110 delay_inf = routing_states%tabulated_delay(lim_inf_ind_mu)
    delay_sup = routing_states%tabulated_delay(lim_sup_ind_mu)
!index_dx=routing_mesh%index_varying_dx(current-node)
!trick for differentiation
    diffcoef = routing_states%tabulated_routing_coef(:, lim_sup_ind_mu, &
&     1, index_dx) - routing_states%tabulated_routing_coef(:, &
&     lim_inf_ind_mu, 1, index_dx)
    delayb = SUM(diffcoef*gamma_coefficientb)/(delay_sup-delay_inf)
    CALL POPINTEGER4(ad_count)
    DO i0=1,ad_count
      IF (i0 .EQ. 1) CALL POPCONTROL1B(branch)
    END DO
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR_B

  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR(delay, index_dx, &
&   routing_states, gamma_coefficient)
    IMPLICIT NONE
    REAL, INTENT(IN) :: delay
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficient
    INTEGER :: i, lim_sup_ind_mu, lim_inf_ind_mu
    REAL :: delay_inf, delay_sup
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: diffcoef
    lim_inf_ind_mu = 1
    lim_sup_ind_mu = 2
!search indices
    DO i=1,routing_states%nb_mode
      IF (delay .LT. routing_states%tabulated_delay(i)) THEN
        lim_inf_ind_mu = i - 1
        lim_sup_ind_mu = i
        GOTO 100
      END IF
    END DO
 100 delay_inf = routing_states%tabulated_delay(lim_inf_ind_mu)
    delay_sup = routing_states%tabulated_delay(lim_sup_ind_mu)
!index_dx=routing_mesh%index_varying_dx(current-node)
!trick for differentiation
    diffcoef = routing_states%tabulated_routing_coef(:, lim_sup_ind_mu, &
&     1, index_dx) - routing_states%tabulated_routing_coef(:, &
&     lim_inf_ind_mu, 1, index_dx)
    gamma_coefficient = routing_states%tabulated_routing_coef(:, &
&     lim_inf_ind_mu, 1, index_dx) + (delay-delay_inf)*diffcoef/(&
&     delay_sup-delay_inf)
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_LINEAR

!  Differentiation of interpolated_routing_coefficients_bilinear in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: gamma_coefficient
!   with respect to varying inputs: mode spreading
  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR_B(mode, modeb, &
&   spreading, spreadingb, index_dx, routing_states, gamma_coefficient, &
&   gamma_coefficientb)
    IMPLICIT NONE
    REAL, INTENT(IN) :: mode
    REAL :: modeb
    REAL, INTENT(IN) :: spreading
    REAL :: spreadingb
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficientb
    INTEGER :: i
    INTEGER :: ix1, iy1, ix2, iy2
    REAL :: x1, y1, x2, y2
    REAL :: wx1, wx2, wy1, wy2
    REAL :: wx1b, wx2b, wy1b, wy2b
    REAL :: x, y
    REAL :: xb, yb
    INTRINSIC MIN
    INTRINSIC MAX
    REAL :: y3b
    REAL :: y4b
    REAL :: tempb
    REAL :: tempb0
    REAL :: tempb1
    REAL :: tempb2
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
    INTEGER :: ad_count0
    INTEGER :: i1
    INTEGER :: y6
    INTEGER :: y5
    REAL :: y4
    REAL :: y3
    IF (mode .GT. routing_states%tabulated_delay(routing_states%nb_mode)&
&   ) THEN
      y3 = routing_states%tabulated_delay(routing_states%nb_mode)
      CALL PUSHCONTROL1B(0)
    ELSE
      y3 = mode
      CALL PUSHCONTROL1B(1)
    END IF
    IF (routing_states%tabulated_delay(1) .LT. y3) THEN
      x = y3
      CALL PUSHCONTROL1B(0)
    ELSE
      x = routing_states%tabulated_delay(1)
      CALL PUSHCONTROL1B(1)
    END IF
    IF (spreading .GT. routing_states%tabulated_spreading(routing_states&
&       %nb_spreads)) THEN
      y4 = routing_states%tabulated_spreading(routing_states%nb_spreads)
      CALL PUSHCONTROL1B(0)
    ELSE
      y4 = spreading
      CALL PUSHCONTROL1B(1)
    END IF
    IF (routing_states%tabulated_spreading(1) .LT. y4) THEN
      y = y4
      CALL PUSHCONTROL1B(0)
    ELSE
      y = routing_states%tabulated_spreading(1)
      CALL PUSHCONTROL1B(1)
    END IF
!search indices for delay x
    ix1 = 1
    ad_count = 1
    DO i=1,routing_states%nb_mode-1
      IF (x .LT. routing_states%tabulated_delay(i+1)) THEN
        GOTO 100
      ELSE
        ad_count = ad_count + 1
      END IF
    END DO
    CALL PUSHCONTROL1B(0)
    CALL PUSHINTEGER4(ad_count)
    GOTO 110
 100 CALL PUSHCONTROL1B(1)
    CALL PUSHINTEGER4(ad_count)
    ix1 = i
 110 IF (ix1 .GT. routing_states%nb_mode - 1) THEN
      y5 = routing_states%nb_mode - 1
    ELSE
      y5 = ix1
    END IF
    IF (1 .LT. y5) THEN
      ix1 = y5
    ELSE
      ix1 = 1
    END IF
    IF (ix1 + 1 .GT. routing_states%nb_mode) THEN
      ix2 = routing_states%nb_mode
    ELSE
      ix2 = ix1 + 1
    END IF
!search indices for spreading y
    iy1 = 1
    ad_count0 = 1
    DO i=1,routing_states%nb_spreads-1
      IF (y .LT. routing_states%tabulated_spreading(i+1)) THEN
        GOTO 120
      ELSE
        ad_count0 = ad_count0 + 1
      END IF
    END DO
    CALL PUSHCONTROL1B(0)
    CALL PUSHINTEGER4(ad_count0)
    GOTO 130
 120 CALL PUSHCONTROL1B(1)
    CALL PUSHINTEGER4(ad_count0)
    iy1 = i
 130 IF (iy1 .GT. routing_states%nb_spreads - 1) THEN
      y6 = routing_states%nb_spreads - 1
    ELSE
      y6 = iy1
    END IF
    IF (1 .LT. y6) THEN
      iy1 = y6
    ELSE
      iy1 = 1
    END IF
    IF (iy1 + 1 .GT. routing_states%nb_spreads) THEN
      iy2 = routing_states%nb_spreads
    ELSE
      iy2 = iy1 + 1
    END IF
    x1 = routing_states%tabulated_delay(ix1)
    x2 = routing_states%tabulated_delay(ix2)
    y1 = routing_states%tabulated_spreading(iy1)
    y2 = routing_states%tabulated_spreading(iy2)
!~         gamma_coefficient=&
!~         & ((mode-x2)/(x1-x2)) * ((spreading-y2)/(y1-y2)) * &
!~         &routing_states%tabulated_routing_coef(:,ix1,iy1,index_dx)&
!~         &+((mode-x1)/(x2-x1)) * ((spreading-y2)/(y1-y2)) * &
!~         &routing_states%tabulated_routing_coef(:,ix2,iy1,index_dx)&
!~         &+((mode-x2)/(x1-x2)) * ((spreading-y1)/(y2-y1)) * &
!~         &routing_states%tabulated_routing_coef(:,ix1,iy2,index_dx)&
!~         &+((mode-x1)/(x2-x1)) * ((spreading-y1)/(y2-y1)) * &
!~         &routing_states%tabulated_routing_coef(:,ix2,iy2,index_dx)
    wx1 = (x2-x)/(x2-x1)
    wx2 = (x-x1)/(x2-x1)
    wy1 = (y2-y)/(y2-y1)
    wy2 = (y-y1)/(y2-y1)
    tempb = SUM(routing_states%tabulated_routing_coef(:, ix1, iy1, &
&     index_dx)*gamma_coefficientb)
    tempb0 = SUM(routing_states%tabulated_routing_coef(:, ix2, iy1, &
&     index_dx)*gamma_coefficientb)
    tempb1 = SUM(routing_states%tabulated_routing_coef(:, ix1, iy2, &
&     index_dx)*gamma_coefficientb)
    tempb2 = SUM(routing_states%tabulated_routing_coef(:, ix2, iy2, &
&     index_dx)*gamma_coefficientb)
    wx2b = wy2*tempb2 + wy1*tempb0
    wy2b = wx2*tempb2 + wx1*tempb1
    wx1b = wy2*tempb1 + wy1*tempb
    wy1b = wx2*tempb0 + wx1*tempb
    yb = wy2b/(y2-y1) - wy1b/(y2-y1)
    xb = wx2b/(x2-x1) - wx1b/(x2-x1)
    CALL POPINTEGER4(ad_count0)
    DO i1=1,ad_count0
      IF (i1 .EQ. 1) CALL POPCONTROL1B(branch)
    END DO
    CALL POPINTEGER4(ad_count)
    DO i0=1,ad_count
      IF (i0 .EQ. 1) CALL POPCONTROL1B(branch)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      y4b = yb
    ELSE
      y4b = 0.0
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      spreadingb = 0.0
    ELSE
      spreadingb = y4b
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      y3b = xb
    ELSE
      y3b = 0.0
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      modeb = 0.0
    ELSE
      modeb = y3b
    END IF
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR_B

  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR(mode, spreading&
&   , index_dx, routing_states, gamma_coefficient)
    IMPLICIT NONE
    REAL, INTENT(IN) :: mode
    REAL, INTENT(IN) :: spreading
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficient
    INTEGER :: i
    INTEGER :: ix1, iy1, ix2, iy2
    REAL :: x1, y1, x2, y2
    REAL :: wx1, wx2, wy1, wy2
    REAL :: x, y
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: y6
    INTEGER :: y5
    REAL :: y4
    REAL :: y3
    IF (mode .GT. routing_states%tabulated_delay(routing_states%nb_mode)&
&   ) THEN
      y3 = routing_states%tabulated_delay(routing_states%nb_mode)
    ELSE
      y3 = mode
    END IF
    IF (routing_states%tabulated_delay(1) .LT. y3) THEN
      x = y3
    ELSE
      x = routing_states%tabulated_delay(1)
    END IF
    IF (spreading .GT. routing_states%tabulated_spreading(routing_states&
&       %nb_spreads)) THEN
      y4 = routing_states%tabulated_spreading(routing_states%nb_spreads)
    ELSE
      y4 = spreading
    END IF
    IF (routing_states%tabulated_spreading(1) .LT. y4) THEN
      y = y4
    ELSE
      y = routing_states%tabulated_spreading(1)
    END IF
!search indices for delay x
    ix1 = 1
    DO i=1,routing_states%nb_mode-1
      IF (x .LT. routing_states%tabulated_delay(i+1)) THEN
        ix1 = i
        GOTO 100
      END IF
    END DO
 100 IF (ix1 .GT. routing_states%nb_mode - 1) THEN
      y5 = routing_states%nb_mode - 1
    ELSE
      y5 = ix1
    END IF
    IF (1 .LT. y5) THEN
      ix1 = y5
    ELSE
      ix1 = 1
    END IF
    IF (ix1 + 1 .GT. routing_states%nb_mode) THEN
      ix2 = routing_states%nb_mode
    ELSE
      ix2 = ix1 + 1
    END IF
!search indices for spreading y
    iy1 = 1
    DO i=1,routing_states%nb_spreads-1
      IF (y .LT. routing_states%tabulated_spreading(i+1)) THEN
        iy1 = i
        GOTO 110
      END IF
    END DO
 110 IF (iy1 .GT. routing_states%nb_spreads - 1) THEN
      y6 = routing_states%nb_spreads - 1
    ELSE
      y6 = iy1
    END IF
    IF (1 .LT. y6) THEN
      iy1 = y6
    ELSE
      iy1 = 1
    END IF
    IF (iy1 + 1 .GT. routing_states%nb_spreads) THEN
      iy2 = routing_states%nb_spreads
    ELSE
      iy2 = iy1 + 1
    END IF
    x1 = routing_states%tabulated_delay(ix1)
    x2 = routing_states%tabulated_delay(ix2)
    y1 = routing_states%tabulated_spreading(iy1)
    y2 = routing_states%tabulated_spreading(iy2)
!~         gamma_coefficient=&
!~         & ((mode-x2)/(x1-x2)) * ((spreading-y2)/(y1-y2)) * &
!~         &routing_states%tabulated_routing_coef(:,ix1,iy1,index_dx)&
!~         &+((mode-x1)/(x2-x1)) * ((spreading-y2)/(y1-y2)) * &
!~         &routing_states%tabulated_routing_coef(:,ix2,iy1,index_dx)&
!~         &+((mode-x2)/(x1-x2)) * ((spreading-y1)/(y2-y1)) * &
!~         &routing_states%tabulated_routing_coef(:,ix1,iy2,index_dx)&
!~         &+((mode-x1)/(x2-x1)) * ((spreading-y1)/(y2-y1)) * &
!~         &routing_states%tabulated_routing_coef(:,ix2,iy2,index_dx)
    wx1 = (x2-x)/(x2-x1)
    wx2 = (x-x1)/(x2-x1)
    wy1 = (y2-y)/(y2-y1)
    wy2 = (y-y1)/(y2-y1)
    gamma_coefficient = wx1*wy1*routing_states%tabulated_routing_coef(:&
&     , ix1, iy1, index_dx) + wx2*wy1*routing_states%&
&     tabulated_routing_coef(:, ix2, iy1, index_dx) + wx1*wy2*&
&     routing_states%tabulated_routing_coef(:, ix1, iy2, index_dx) + wx2&
&     *wy2*routing_states%tabulated_routing_coef(:, ix2, iy2, index_dx)
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BILINEAR

  SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BICUBIC(mode, spreading, &
&   index_dx, routing_states, gamma_coefficient)
    IMPLICIT NONE
    REAL, INTENT(IN) :: mode, spreading
    INTEGER, INTENT(IN) :: index_dx
    TYPE(TYPE_ROUTING_STATES), INTENT(IN) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(OUT) :: &
&   gamma_coefficient
    INTEGER :: i, j, ix, iy
    REAL :: x, y
    REAL :: x1, x2, x0, x3
    REAL :: y1, y2, y0, y3
    REAL :: t, u
    REAL, DIMENSION(4) :: px, py
    REAL, DIMENSION(4, 4) :: f
    REAL :: cubic_interp
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: y7
    INTEGER :: y6
    REAL :: y5
    REAL :: y4
    IF (mode .GT. routing_states%tabulated_delay(routing_states%nb_mode)&
&   ) THEN
      y4 = routing_states%tabulated_delay(routing_states%nb_mode)
    ELSE
      y4 = mode
    END IF
    IF (routing_states%tabulated_delay(1) .LT. y4) THEN
      x = y4
    ELSE
      x = routing_states%tabulated_delay(1)
    END IF
    IF (spreading .GT. routing_states%tabulated_spreading(routing_states&
&       %nb_spreads)) THEN
      y5 = routing_states%tabulated_spreading(routing_states%nb_spreads)
    ELSE
      y5 = spreading
    END IF
    IF (routing_states%tabulated_spreading(1) .LT. y5) THEN
      y = y5
    ELSE
      y = routing_states%tabulated_spreading(1)
    END IF
!-------------------------------
! Find lower index for mode (x)
!-------------------------------
    ix = 2
    DO i=2,routing_states%nb_mode
      IF (x .LT. routing_states%tabulated_delay(i)) THEN
        ix = i - 1
        GOTO 100
      END IF
    END DO
 100 IF (ix .GT. routing_states%nb_mode - 2) THEN
      y6 = routing_states%nb_mode - 2
    ELSE
      y6 = ix
    END IF
    IF (2 .LT. y6) THEN
      ix = y6
    ELSE
      ix = 2
    END IF
    x0 = routing_states%tabulated_delay(ix-1)
    x1 = routing_states%tabulated_delay(ix)
    x2 = routing_states%tabulated_delay(ix+1)
    x3 = routing_states%tabulated_delay(ix+2)
    t = (x-x1)/(x2-x1)
!-------------------------------
! Find lower index for spreading (y)
!-------------------------------
    iy = 2
    DO i=2,routing_states%nb_spreads
      IF (y .LT. routing_states%tabulated_spreading(i)) THEN
        iy = i - 1
        GOTO 110
      END IF
    END DO
 110 IF (iy .GT. routing_states%nb_spreads - 2) THEN
      y7 = routing_states%nb_spreads - 2
    ELSE
      y7 = iy
    END IF
    IF (2 .LT. y7) THEN
      iy = y7
    ELSE
      iy = 2
    END IF
    y0 = routing_states%tabulated_spreading(iy-1)
    y1 = routing_states%tabulated_spreading(iy)
    y2 = routing_states%tabulated_spreading(iy+1)
    y3 = routing_states%tabulated_spreading(iy+2)
    u = (y-y1)/(y2-y1)
!-------------------------------
! Extract 4x4 neighborhood
!-------------------------------
    DO i=1,SIZE(gamma_coefficient)
      f(1, 1) = routing_states%tabulated_routing_coef(i, ix-1, iy-1, &
&       index_dx)
      f(2, 1) = routing_states%tabulated_routing_coef(i, ix, iy-1, &
&       index_dx)
      f(3, 1) = routing_states%tabulated_routing_coef(i, ix+1, iy-1, &
&       index_dx)
      f(4, 1) = routing_states%tabulated_routing_coef(i, ix+2, iy-1, &
&       index_dx)
      f(1, 2) = routing_states%tabulated_routing_coef(i, ix-1, iy, &
&       index_dx)
      f(2, 2) = routing_states%tabulated_routing_coef(i, ix, iy, &
&       index_dx)
      f(3, 2) = routing_states%tabulated_routing_coef(i, ix+1, iy, &
&       index_dx)
      f(4, 2) = routing_states%tabulated_routing_coef(i, ix+2, iy, &
&       index_dx)
      f(1, 3) = routing_states%tabulated_routing_coef(i, ix-1, iy+1, &
&       index_dx)
      f(2, 3) = routing_states%tabulated_routing_coef(i, ix, iy+1, &
&       index_dx)
      f(3, 3) = routing_states%tabulated_routing_coef(i, ix+1, iy+1, &
&       index_dx)
      f(4, 3) = routing_states%tabulated_routing_coef(i, ix+2, iy+1, &
&       index_dx)
      f(1, 4) = routing_states%tabulated_routing_coef(i, ix-1, iy+2, &
&       index_dx)
      f(2, 4) = routing_states%tabulated_routing_coef(i, ix, iy+2, &
&       index_dx)
      f(3, 4) = routing_states%tabulated_routing_coef(i, ix+1, iy+2, &
&       index_dx)
      f(4, 4) = routing_states%tabulated_routing_coef(i, ix+2, iy+2, &
&       index_dx)
!-------------------------------
! Bicubic interpolation in x then y
!-------------------------------
      DO j=1,4
        px(j) = CUBIC_HERMITE(f(1, j), f(2, j), f(3, j), f(4, j), t)
      END DO
      gamma_coefficient(i) = CUBIC_HERMITE(px(1), px(2), px(3), px(4), u&
&       )
    END DO
  END SUBROUTINE INTERPOLATED_ROUTING_COEFFICIENTS_BICUBIC

!-------------------------------------------------
! Cubic Hermite interpolation (C1 continuous)
!-------------------------------------------------
  REAL FUNCTION CUBIC_HERMITE(f0, f1, f2, f3, s)
    IMPLICIT NONE
    REAL, INTENT(IN) :: f0, f1, f2, f3, s
    REAL :: a0, a1, a2, a3
    a0 = f1
    a1 = 0.5*(f2-f0)
    a2 = f0 - 2.5*f1 + 2.0*f2 - 0.5*f3
    a3 = -(0.5*f0) + 1.5*f1 - 1.5*f2 + 0.5*f3
    cubic_hermite = a0 + a1*s + a2*s*s + a3*s*s*s
  END FUNCTION CUBIC_HERMITE

!  Differentiation of localmemstorage in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: routingmem.states
!   with respect to varying inputs: gamma_coefficient routingmem.states
!                qcell
!>Store and spread in memory the delayed discharge
  SUBROUTINE LOCALMEMSTORAGE_B(routing_mesh, routing_states, &
&   gamma_coefficient, gamma_coefficientb, qcell, qcellb, current_node, &
&   routingmem, routingmemb)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(IN) :: &
&   gamma_coefficient
    REAL, DIMENSION(SIZE(routing_states%quantile)) :: gamma_coefficientb
    REAL, INTENT(IN) :: qcell
    REAL :: qcellb
    INTEGER, INTENT(IN) :: current_node
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmemb
    INTEGER :: t
    gamma_coefficientb = 0.0
    qcellb = 0.0
    DO t=routing_states%window_length(current_node),1,-1
      gamma_coefficientb(t) = gamma_coefficientb(t) + qcell*routingmemb(&
&       t, current_node)%states
      qcellb = qcellb + gamma_coefficient(t)*routingmemb(t, current_node&
&       )%states
    END DO
  END SUBROUTINE LOCALMEMSTORAGE_B

!>Store and spread in memory the delayed discharge
  SUBROUTINE LOCALMEMSTORAGE(routing_mesh, routing_states, &
&   gamma_coefficient, qcell, current_node, routingmem)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    INTRINSIC SIZE
    REAL, DIMENSION(SIZE(routing_states%quantile)), INTENT(IN) :: &
&   gamma_coefficient
    REAL, INTENT(IN) :: qcell
    INTEGER, INTENT(IN) :: current_node
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    INTEGER :: t
    DO t=1,routing_states%window_length(current_node)
      routingmem(t, current_node)%states = routingmem(t, current_node)%&
&       states + gamma_coefficient(t)*qcell
    END DO
  END SUBROUTINE LOCALMEMSTORAGE

!  Differentiation of memmasstransfert in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: routingmem.states routingmem.remainder
!   with respect to varying inputs: routingmem.states routingmem.remainder
!>Switch up in time the local memory_storage array at position ix,iy
  SUBROUTINE MEMMASSTRANSFERT_B(routing_states, routing_setup, &
&   routing_mesh, current_node, routingmem, routingmemb)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    INTEGER, INTENT(IN) :: current_node
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmemb
    INTEGER :: nbmemcell
    INTEGER :: upstream_node
    INTEGER :: t
    INTEGER :: i
    REAL :: dqfill
    REAL :: dqfillb
    REAL :: inv_elongation_factor
    INTEGER :: ad_to
    INTEGER :: branch
    IF (routing_mesh%cum_node_index(current_node) .GT. 1) THEN
      inv_elongation_factor = 1./routing_setup%elongation_factor
      DO i=1,routing_mesh%nb_upstream_nodes
        upstream_node = routing_mesh%nodes_linker(i, current_node)
        IF (upstream_node .GT. 0) THEN
          nbmemcell = routing_states%window_length(upstream_node)
!loop over delay in memory
          t = nbmemcell
          CALL PUSHINTEGER4(t - 1)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      DO i=routing_mesh%nb_upstream_nodes,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          upstream_node = routing_mesh%nodes_linker(i, current_node)
          nbmemcell = routing_states%window_length(upstream_node)
          routingmemb(nbmemcell, upstream_node)%remainder = 0.0
          routingmemb(nbmemcell, upstream_node)%states = 0.0
          CALL POPINTEGER4(ad_to)
          DO t=ad_to,1,-1
            dqfillb = routingmemb(t, upstream_node)%states - routingmemb&
&             (t, upstream_node)%remainder
            routingmemb(t+1, upstream_node)%states = routingmemb(t+1, &
&             upstream_node)%states + routingmemb(t, upstream_node)%&
&             remainder + inv_elongation_factor*dqfillb
            routingmemb(t, upstream_node)%remainder = routingmemb(t, &
&             upstream_node)%states
            routingmemb(t, upstream_node)%states = 0.0
          END DO
        END IF
      END DO
    END IF
  END SUBROUTINE MEMMASSTRANSFERT_B

!>Switch up in time the local memory_storage array at position ix,iy
  PURE SUBROUTINE MEMMASSTRANSFERT(routing_states, routing_setup, &
&   routing_mesh, current_node, routingmem)
    IMPLICIT NONE
    TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
    TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
    TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
    INTEGER, INTENT(IN) :: current_node
    INTRINSIC SIZE
    TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
&   routing_mesh%nb_nodes), INTENT(INOUT) :: routingmem
    INTEGER :: nbmemcell
    INTEGER :: upstream_node
    INTEGER :: t
    INTEGER :: i
    REAL :: dqfill
    REAL :: inv_elongation_factor
    IF (routing_mesh%cum_node_index(current_node) .GT. 1) THEN
      inv_elongation_factor = 1./routing_setup%elongation_factor
      DO i=1,routing_mesh%nb_upstream_nodes
        upstream_node = routing_mesh%nodes_linker(i, current_node)
        IF (upstream_node .GT. 0) THEN
          nbmemcell = routing_states%window_length(upstream_node)
!loop over delay in memory
          DO t=1,nbmemcell-1
            dqfill = inv_elongation_factor*routingmem(t+1, upstream_node&
&             )%states
            routingmem(t, upstream_node)%states = dqfill + routingmem(t&
&             , upstream_node)%remainder
            routingmem(t, upstream_node)%remainder = routingmem(t+1, &
&             upstream_node)%states - dqfill
          END DO
!last time step in memory
          routingmem(nbmemcell, upstream_node)%states = 0.
          routingmem(nbmemcell, upstream_node)%remainder = 0.
        END IF
      END DO
    END IF
  END SUBROUTINE MEMMASSTRANSFERT

END MODULE MOD_GAMMA_ROUTING_DIFF

!  Differentiation of routing_hydrogram_forward in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: inflows
!   RW status of diff variables: inflows:out *(routing_parameter.hydraulics_coefficient):(loc)
!                *(routing_parameter.spreading):(loc) cost:in-killed
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
SUBROUTINE ROUTING_HYDROGRAM_FORWARD_B0(routing_setup, routing_mesh, &
& routing_parameter, routing_parameterb, inflows, inflowsb, observations&
& , routing_states, routing_results, cost, costb)
! Notes
! -----
! **routing_hydrogram_forward(routing_setup,routing_mesh,routing_parameter,inflows,observations,routing_states,routing_results,co
!st)** :
!
! - Run the model an propagate the hydrogram thanks to the inflows and compute the cost function. This subroutine is differentiab
!le
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_setup``                       routing_setup Derived Type (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``routing_parameter``                   routing_parameter Derived Type (in)
! ``inflows``                             Inflows, array(npdt,nb_nodes) (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``routing_states``                      Routing_mesh Derived Type (inout)
! ``routing_results``                     Routing_results Derived Type (inout)
! ``cost``                                Cost function evaluation (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  USE MOD_GAMMA_ROUTING_STATES_DIFF
  USE MOD_GAMMA_ROUTING_RESULTS
  USE MOD_GAMMA_ROUTING_DIFF
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
  TYPE(TYPE_ROUTING_PARAMETER_DIFF), INTENT(INOUT) :: routing_parameterb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: inflows
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: inflowsb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
  TYPE(TYPE_ROUTING_RESULTS), INTENT(INOUT) :: routing_results
  REAL :: cost
  REAL :: costb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: qnetwork
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
& qnetworkb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: vnetwork
  REAL, DIMENSION(3) :: tab_cost
  INTEGER :: i
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmesh
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmeshb
  REAL, DIMENSION(routing_mesh%nb_nodes) :: velocities
  REAL, DIMENSION(routing_mesh%nb_nodes) :: inflow
  REAL, DIMENSION(routing_mesh%nb_nodes) :: inflowb
  INTRINSIC SIZE
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmem
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmemb
  REAL :: tmp
  REAL :: tmp0
  IF (routing_setup%hydraulics_coef_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      tmp = routing_parameter%hydraulics_coefficient(1)
      routing_parameter%hydraulics_coefficient(i) = tmp
    END DO
  END IF
  IF (routing_setup%spreading_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      tmp0 = routing_parameter%spreading(1)
      routing_parameter%spreading(i) = tmp0
    END DO
  END IF
!Here we should denormalise parameter if nedeed:
!if routing_setup_normalized=True:
!   call denormalized(routing_parameter)
  routingmem(:, :)%states = routing_states%states
  routingmem(:, :)%remainder = routing_states%remainder
  DO i=1,routing_setup%npdt
    qmesh = 0.
    inflow = inflows(i, 1:routing_mesh%nb_nodes)
    CALL PUSHREAL4ARRAY(routingmem%states, SIZE(routing_states%quantile)&
&                 *routing_mesh%nb_nodes)
    CALL PUSHREAL4ARRAY(routingmem%remainder, SIZE(routing_states%&
&                 quantile)*routing_mesh%nb_nodes)
    CALL ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter, &
&               inflow, routing_states, routingmem, qmesh, velocities)
    qnetwork(i, :) = qmesh
  END DO
 CALL COST_FUNCTION(routing_setup,routing_mesh,routing_parameter,observations,qnetwork,tab_cost,cost)
  CALL COST_FUNCTION_B(routing_setup, routing_mesh, routing_parameter, &
&                routing_parameterb, observations, qnetwork, qnetworkb, &
&                tab_cost, cost, costb)
  inflowsb = 0.0
  routingmemb%states = 0.0
  routingmemb%remainder = 0.0
  DO i=routing_setup%npdt,1,-1
    qmeshb = 0.0
    qmeshb = qnetworkb(i, :)
    qnetworkb(i, :) = 0.0
    inflow = inflows(i, 1:routing_mesh%nb_nodes)
    CALL POPREAL4ARRAY(routingmem%remainder, SIZE(routing_states%&
&                quantile)*routing_mesh%nb_nodes)
    CALL POPREAL4ARRAY(routingmem%states, SIZE(routing_states%quantile)*&
&                routing_mesh%nb_nodes)
    routing_parameterb%hydraulics_coefficient = 0.0
    routing_parameterb%spreading = 0.0
    CALL ROUTING_FLOW_B(routing_setup, routing_mesh, routing_parameter, &
&                 routing_parameterb, inflow, inflowb, routing_states, &
&                 routingmem, routingmemb, qmesh, qmeshb, velocities)
    inflowsb(i, :) = inflowsb(i, :) + inflowb
  END DO
END SUBROUTINE ROUTING_HYDROGRAM_FORWARD_B0

!  Differentiation of routing_hydrogram_forward in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost
!   with respect to varying inputs: *(routing_parameter.hydraulics_coefficient)
!                *(routing_parameter.spreading)
!   RW status of diff variables: routing_parameter.hydraulics_coefficient:(loc)
!                *(routing_parameter.hydraulics_coefficient):out
!                routing_parameter.spreading:(loc) *(routing_parameter.spreading):out
!                cost:in-killed
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
SUBROUTINE ROUTING_HYDROGRAM_FORWARD_B(routing_setup, routing_mesh, &
& routing_parameter, routing_parameterb, inflows, observations, &
& routing_states, routing_results, cost, costb)
! Notes
! -----
! **routing_hydrogram_forward(routing_setup,routing_mesh,routing_parameter,inflows,observations,routing_states,routing_results,co
!st)** :
!
! - Run the model an propagate the hydrogram thanks to the inflows and compute the cost function. This subroutine is differentiab
!le
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_setup``                       routing_setup Derived Type (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``routing_parameter``                   routing_parameter Derived Type (in)
! ``inflows``                             Inflows, array(npdt,nb_nodes) (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``routing_states``                      Routing_mesh Derived Type (inout)
! ``routing_results``                     Routing_results Derived Type (inout)
! ``cost``                                Cost function evaluation (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  USE MOD_GAMMA_ROUTING_STATES_DIFF
  USE MOD_GAMMA_ROUTING_RESULTS
  USE MOD_GAMMA_ROUTING_DIFF
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
  TYPE(TYPE_ROUTING_PARAMETER_DIFF), INTENT(INOUT) :: routing_parameterb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: inflows
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: inflowsb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
  TYPE(TYPE_ROUTING_RESULTS), INTENT(INOUT) :: routing_results
  REAL :: cost
  REAL :: costb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: qnetwork
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
& qnetworkb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: vnetwork
  REAL, DIMENSION(3) :: tab_cost
  INTEGER :: i
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmesh
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmeshb
  REAL, DIMENSION(routing_mesh%nb_nodes) :: velocities
  REAL, DIMENSION(routing_mesh%nb_nodes) :: inflow
  REAL, DIMENSION(routing_mesh%nb_nodes) :: inflowb
  INTRINSIC SIZE
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmem
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmemb
  REAL :: tmp
  REAL :: tmpb
  REAL :: tmp0
  REAL :: tmpb0
  INTEGER :: branch
  IF (routing_setup%hydraulics_coef_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      tmp = routing_parameter%hydraulics_coefficient(1)
      routing_parameter%hydraulics_coefficient(i) = tmp
    END DO
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (routing_setup%spreading_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      tmp0 = routing_parameter%spreading(1)
      routing_parameter%spreading(i) = tmp0
    END DO
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!Here we should denormalise parameter if nedeed:
!if routing_setup_normalized=True:
!   call denormalized(routing_parameter)
  routingmem(:, :)%states = routing_states%states
  routingmem(:, :)%remainder = routing_states%remainder
  DO i=1,routing_setup%npdt
    qmesh = 0.
    inflow = inflows(i, 1:routing_mesh%nb_nodes)
    CALL PUSHREAL4ARRAY(routingmem%states, SIZE(routing_states%quantile)&
&                 *routing_mesh%nb_nodes)
    CALL PUSHREAL4ARRAY(routingmem%remainder, SIZE(routing_states%&
&                 quantile)*routing_mesh%nb_nodes)
    CALL ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter, &
&               inflow, routing_states, routingmem, qmesh, velocities)
    qnetwork(i, :) = qmesh
  END DO
 CALL COST_FUNCTION(routing_setup,routing_mesh,routing_parameter,observations,qnetwork,tab_cost,cost)
  CALL COST_FUNCTION_B(routing_setup, routing_mesh, routing_parameter, &
&                routing_parameterb, observations, qnetwork, qnetworkb, &
&                tab_cost, cost, costb)
  routingmemb%states = 0.0
  routingmemb%remainder = 0.0
  DO i=routing_setup%npdt,1,-1
    qmeshb = 0.0
    qmeshb = qnetworkb(i, :)
    qnetworkb(i, :) = 0.0
    inflow = inflows(i, 1:routing_mesh%nb_nodes)
    CALL POPREAL4ARRAY(routingmem%remainder, SIZE(routing_states%&
&                quantile)*routing_mesh%nb_nodes)
    CALL POPREAL4ARRAY(routingmem%states, SIZE(routing_states%quantile)*&
&                routing_mesh%nb_nodes)
    CALL ROUTING_FLOW_B(routing_setup, routing_mesh, routing_parameter, &
&                 routing_parameterb, inflow, inflowb, routing_states, &
&                 routingmem, routingmemb, qmesh, qmeshb, velocities)
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO i=routing_mesh%nb_nodes,1,-1
      tmpb0 = routing_parameterb%spreading(i)
      routing_parameterb%spreading(i) = 0.0
      routing_parameterb%spreading(1) = routing_parameterb%spreading(1) &
&       + tmpb0
    END DO
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO i=routing_mesh%nb_nodes,1,-1
      tmpb = routing_parameterb%hydraulics_coefficient(i)
      routing_parameterb%hydraulics_coefficient(i) = 0.0
      routing_parameterb%hydraulics_coefficient(1) = routing_parameterb%&
&       hydraulics_coefficient(1) + tmpb
    END DO
  END IF
END SUBROUTINE ROUTING_HYDROGRAM_FORWARD_B

!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
SUBROUTINE ROUTING_HYDROGRAM_FORWARD_NODIFF(routing_setup, routing_mesh&
& , routing_parameter, inflows, observations, routing_states, &
& routing_results, cost)
! Notes
! -----
! **routing_hydrogram_forward(routing_setup,routing_mesh,routing_parameter,inflows,observations,routing_states,routing_results,co
!st)** :
!
! - Run the model an propagate the hydrogram thanks to the inflows and compute the cost function. This subroutine is differentiab
!le
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``routing_setup``                       routing_setup Derived Type (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``routing_parameter``                   routing_parameter Derived Type (in)
! ``inflows``                             Inflows, array(npdt,nb_nodes) (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``routing_states``                      Routing_mesh Derived Type (inout)
! ``routing_results``                     Routing_results Derived Type (inout)
! ``cost``                                Cost function evaluation (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  USE MOD_GAMMA_ROUTING_STATES_DIFF
  USE MOD_GAMMA_ROUTING_RESULTS
  USE MOD_GAMMA_ROUTING_DIFF
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(INOUT) :: routing_parameter
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: inflows
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  TYPE(TYPE_ROUTING_STATES), INTENT(INOUT) :: routing_states
  TYPE(TYPE_ROUTING_RESULTS), INTENT(INOUT) :: routing_results
  REAL, INTENT(OUT) :: cost
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: qnetwork
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: vnetwork
  REAL, DIMENSION(3) :: tab_cost
  INTEGER :: i
  REAL, DIMENSION(routing_mesh%nb_nodes) :: qmesh
  REAL, DIMENSION(routing_mesh%nb_nodes) :: velocities
  REAL, DIMENSION(routing_mesh%nb_nodes) :: inflow
  INTRINSIC SIZE
  TYPE(ROUTING_MEMORY), DIMENSION(SIZE(routing_states%quantile), &
& routing_mesh%nb_nodes) :: routingmem
  IF (routing_setup%hydraulics_coef_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      routing_parameter%hydraulics_coefficient(i) = routing_parameter%&
&       hydraulics_coefficient(1)
    END DO
  END IF
  IF (routing_setup%spreading_uniform .EQ. 1) THEN
    DO i=1,routing_mesh%nb_nodes
      routing_parameter%spreading(i) = routing_parameter%spreading(1)
    END DO
  END IF
!Here we should denormalise parameter if nedeed:
!if routing_setup_normalized=True:
!   call denormalized(routing_parameter)
  routingmem(:, :)%states = routing_states%states
  routingmem(:, :)%remainder = routing_states%remainder
  DO i=1,routing_setup%npdt
    velocities = 0.
    qmesh = 0.
    inflow = inflows(i, 1:routing_mesh%nb_nodes)
    CALL ROUTING_FLOW(routing_setup, routing_mesh, routing_parameter, &
&               inflow, routing_states, routingmem, qmesh, velocities)
    qnetwork(i, :) = qmesh
    vnetwork(i, :) = velocities
  END DO
  CALL COST_FUNCTION_NODIFF(routing_setup, routing_mesh, &
&                     routing_parameter, observations, qnetwork, &
&                     tab_cost, cost)
!storing results
  routing_results%costs = tab_cost
  routing_results%discharges = qnetwork
  routing_results%velocities = vnetwork
  routing_states%states = routingmem(:, :)%states
  routing_states%remainder = routingmem(:, :)%remainder
END SUBROUTINE ROUTING_HYDROGRAM_FORWARD_NODIFF

!  Differentiation of cost_function in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost_final
!   with respect to varying inputs: *(routing_parameter.hydraulics_coefficient)
!                *(routing_parameter.spreading) qnetwork
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
!~ This file is part of GammaRouting.
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
!>costfun : Fonction cout
SUBROUTINE COST_FUNCTION_B(routing_setup, routing_mesh, &
& routing_parameter, routing_parameterb, observations, qnetwork, &
& qnetworkb, tab_cost, cost_final, cost_finalb)
! Notes
! -----
! **cost_function(npdt,routing_mesh,observations,qnetwork,cost)
!
! - Compute the cost function and return the cost (roots mean square)
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``npdt``                                nimber of time-step, integer (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``qnetwork``                            Discharges in the network, array(npdt,nb_nodes) (inout)
! ``cost``                                Cost, function evaluation, real (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  IMPLICIT NONE
!~     write(*,*) ""
!~     write(*,*) "-----------------------------------------------------"
!~     write(*,*) "cost=",cost_final," ; j0=",cost," ; penalty=",routing_setup%ponderation_regul*penalty
!~     write(*,*) "-----------------------------------------------------"
!~     write(*,*) ""
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  TYPE(TYPE_ROUTING_PARAMETER_DIFF) :: routing_parameterb
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: qnetwork
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes) :: &
& qnetworkb
  REAL, DIMENSION(3), INTENT(INOUT) :: tab_cost
  REAL, INTENT(INOUT) :: cost_final
  REAL, INTENT(INOUT) :: cost_finalb
  REAL :: penalty, cost
  REAL :: penaltyb, costb
  REAL :: num, den, meanobs, sumobs
  REAL :: numb
  INTEGER :: j, i, k, numobs
  INTRINSIC TRIM
  INTEGER :: branch
!write(*,*) any((observations-qnetwork)**2.>0)
  SELECT CASE  (TRIM(routing_setup%criteria)) 
  CASE ('rmse') 
    DO j=1,routing_mesh%nb_nodes
      CALL PUSHINTEGER4(k)
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHCONTROL2B(1)
  CASE ('nse') 
    DO j=1,routing_mesh%nb_nodes
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        sumobs = 0.
        CALL PUSHREAL4(den)
        den = 0.
        numobs = 0
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          sumobs = sumobs + observations(i, k)
          numobs = numobs + 1
        END DO
        IF (numobs .GT. 0) meanobs = sumobs/numobs
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          den = den + (observations(i, k)-meanobs)**2.
        END DO
        IF (den .GT. 0.) THEN
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    CALL PUSHCONTROL2B(2)
  CASE DEFAULT
    CALL PUSHCONTROL2B(0)
  END SELECT
  costb = routing_setup%ponderation_cost*cost_finalb
  penaltyb = routing_setup%ponderation_regul*cost_finalb
  CALL REGULARIZATION_B(routing_mesh, routing_parameter, &
&                 routing_parameterb, penalty, penaltyb)
  CALL POPCONTROL2B(branch)
  IF (branch .EQ. 0) THEN
    qnetworkb = 0.0
  ELSE IF (branch .EQ. 1) THEN
    qnetworkb = 0.0
    DO j=routing_mesh%nb_nodes,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO i=routing_setup%npdt,routing_setup%pdt_start_optim,-1
          qnetworkb(i, k) = qnetworkb(i, k) - 2.*(observations(i, k)-&
&           qnetwork(i, k))*costb
        END DO
      END IF
      CALL POPINTEGER4(k)
    END DO
  ELSE
    qnetworkb = 0.0
    DO j=routing_mesh%nb_nodes,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          numb = 0.0
        ELSE
          numb = costb/den
        END IF
        k = routing_mesh%controlled_nodes(j)
        DO i=routing_setup%npdt,routing_setup%pdt_start_optim,-1
          qnetworkb(i, k) = qnetworkb(i, k) - 2.*(observations(i, k)-&
&           qnetwork(i, k))*numb
        END DO
        CALL POPREAL4(den)
      END IF
    END DO
  END IF
END SUBROUTINE COST_FUNCTION_B

!~ This file is part of GammaRouting.
!~ GammaRouting is a conceptual flow propagation model
!~ Copyright 2022, 2023 Hydris-hydrologie, Maxime Jay-Allemand
!~ This file is part of GammaRouting.
!~ GammaRouting is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as p
!ublished by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!~ GammaRouting is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!~ You should have received a copy of the GNU General Public License along with GammaRouting. If not, see <https://www.gnu.org/li
!censes/>
!~ Contact: maxime.jay.allemand@hydris-hydrologie.fr
!>costfun : Fonction cout
SUBROUTINE COST_FUNCTION_NODIFF(routing_setup, routing_mesh, &
& routing_parameter, observations, qnetwork, tab_cost, cost_final)
! Notes
! -----
! **cost_function(npdt,routing_mesh,observations,qnetwork,cost)
!
! - Compute the cost function and return the cost (roots mean square)
!        
! =============================           ===================================
! Parameters                              Description
! =============================           ===================================
! ``npdt``                                nimber of time-step, integer (in)
! ``routing_mesh``                        Routing_mesh Derived Type (in)
! ``observations``                        Discharges observations, array(npdt,nb_nodes) (in)
! ``qnetwork``                            Discharges in the network, array(npdt,nb_nodes) (inout)
! ``cost``                                Cost, function evaluation, real (inout)
! =============================           ===================================
  USE MOD_GAMMA_ROUTING_SETUP
  USE MOD_GAMMA_ROUTING_MESH
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  IMPLICIT NONE
!~     write(*,*) ""
!~     write(*,*) "-----------------------------------------------------"
!~     write(*,*) "cost=",cost_final," ; j0=",cost," ; penalty=",routing_setup%ponderation_regul*penalty
!~     write(*,*) "-----------------------------------------------------"
!~     write(*,*) ""
  TYPE(TYPE_ROUTING_SETUP), INTENT(IN) :: routing_setup
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: observations
  REAL, DIMENSION(routing_setup%npdt, routing_mesh%nb_nodes), INTENT(IN)&
& :: qnetwork
  REAL, DIMENSION(3), INTENT(INOUT) :: tab_cost
  REAL, INTENT(INOUT) :: cost_final
  REAL :: penalty, cost
  REAL :: num, den, meanobs, sumobs
  INTEGER :: j, i, k, numobs
  INTRINSIC TRIM
  cost = 0.
  tab_cost = 0.
  cost_final = 0.
!write(*,*) any((observations-qnetwork)**2.>0)
  SELECT CASE  (TRIM(routing_setup%criteria)) 
  CASE ('rmse') 
    cost = 0.
    DO j=1,routing_mesh%nb_nodes
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
!write(*,*) i,k,(observations(i,k)-qnetwork(i,k))**2.,observations(i,k),qnetwork(i,k)
!~                     if (observations(i,k).ne.qnetwork(i,k))then
!~                         write(*,*) i,k,(observations(i,k)-qnetwork(i,k))**2.,observations(i,k),qnetwork(i,k)
!~                     end if
          cost = cost + (observations(i, k)-qnetwork(i, k))**2.
        END DO
      END IF
    END DO
  CASE ('nse') 
    cost = 0.
    DO j=1,routing_mesh%nb_nodes
      k = routing_mesh%controlled_nodes(j)
      IF (k .GT. 0 .AND. k .LE. routing_mesh%nb_nodes) THEN
        sumobs = 0.
        num = 0.
        den = 0.
        numobs = 0
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          sumobs = sumobs + observations(i, k)
          numobs = numobs + 1
        END DO
        IF (numobs .GT. 0) meanobs = sumobs/numobs
        DO i=routing_setup%pdt_start_optim,routing_setup%npdt
          num = num + (observations(i, k)-qnetwork(i, k))**2.
          den = den + (observations(i, k)-meanobs)**2.
        END DO
        IF (den .GT. 0.) cost = cost + num/den
      END IF
    END DO
  END SELECT
  penalty = 0.
  CALL REGULARIZATION_NODIFF(routing_mesh, routing_parameter, penalty)
  cost_final = routing_setup%ponderation_cost*cost + routing_setup%&
&   ponderation_regul*penalty
  tab_cost(1) = cost_final
  tab_cost(2) = cost
  tab_cost(3) = penalty
END SUBROUTINE COST_FUNCTION_NODIFF

!  Differentiation of regularization in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: penalty
!   with respect to varying inputs: *(routing_parameter.hydraulics_coefficient)
!                *(routing_parameter.spreading)
!   Plus diff mem management of: routing_parameter.hydraulics_coefficient:in
!                routing_parameter.spreading:in
SUBROUTINE REGULARIZATION_B(routing_mesh, routing_parameter, &
& routing_parameterb, penalty, penaltyb)
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  USE MOD_GAMMA_ROUTING_MESH
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  TYPE(TYPE_ROUTING_PARAMETER_DIFF) :: routing_parameterb
  REAL, INTENT(INOUT) :: penalty
  REAL, INTENT(INOUT) :: penaltyb
  INTEGER :: i, current_node, next_node, previous_node
  REAL :: temp
  REAL :: temp0
  REAL :: temp1
  REAL :: tempb
  REAL :: tempb0
  REAL :: tempb1
  INTEGER :: branch
  DO i=1,routing_mesh%nb_nodes
!order matters
    current_node = routing_mesh%upstream_to_downstream_nodes(i)
    IF (i .LT. routing_mesh%nb_nodes) THEN
      CALL PUSHINTEGER4(next_node)
      next_node = routing_mesh%upstream_to_downstream_nodes(i+1)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHINTEGER4(next_node)
      next_node = current_node
      CALL PUSHCONTROL1B(1)
    END IF
    IF (i .GT. 1) THEN
      CALL PUSHINTEGER4(previous_node)
      previous_node = routing_mesh%upstream_to_downstream_nodes(i-1)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHINTEGER4(previous_node)
      previous_node = current_node
      CALL PUSHCONTROL1B(1)
    END IF
  END DO
  routing_parameterb%hydraulics_coefficient = 0.0
  routing_parameterb%spreading = 0.0
  DO i=routing_mesh%nb_nodes,1,-1
    current_node = routing_mesh%upstream_to_downstream_nodes(i)
    temp1 = routing_parameter%spreading(current_node) - &
&     routing_parameter%spreading(next_node)
    temp0 = routing_parameter%spreading(current_node) - &
&     routing_parameter%spreading(previous_node)
    tempb1 = 2.*(temp0**2.-temp1**2.)*0.5*penaltyb
    tempb0 = 2.*temp0*tempb1
    tempb = -(2.*temp1*tempb1)
    routing_parameterb%spreading(current_node) = routing_parameterb%&
&     spreading(current_node) + tempb
    routing_parameterb%spreading(next_node) = routing_parameterb%&
&     spreading(next_node) - tempb
    routing_parameterb%spreading(current_node) = routing_parameterb%&
&     spreading(current_node) + tempb0
    routing_parameterb%spreading(previous_node) = routing_parameterb%&
&     spreading(previous_node) - tempb0
    temp = routing_parameter%hydraulics_coefficient(current_node) - &
&     routing_parameter%hydraulics_coefficient(next_node)
    temp0 = routing_parameter%hydraulics_coefficient(current_node) - &
&     routing_parameter%hydraulics_coefficient(previous_node)
    tempb = 2.*(temp0**2.-temp**2.)*0.5*penaltyb
    tempb0 = 2.*temp0*tempb
    tempb1 = -(2.*temp*tempb)
    routing_parameterb%hydraulics_coefficient(current_node) = &
&     routing_parameterb%hydraulics_coefficient(current_node) + tempb1
    routing_parameterb%hydraulics_coefficient(next_node) = &
&     routing_parameterb%hydraulics_coefficient(next_node) - tempb1
    routing_parameterb%hydraulics_coefficient(current_node) = &
&     routing_parameterb%hydraulics_coefficient(current_node) + tempb0
    routing_parameterb%hydraulics_coefficient(previous_node) = &
&     routing_parameterb%hydraulics_coefficient(previous_node) - tempb0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER4(previous_node)
    ELSE
      CALL POPINTEGER4(previous_node)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER4(next_node)
    ELSE
      CALL POPINTEGER4(next_node)
    END IF
  END DO
END SUBROUTINE REGULARIZATION_B

SUBROUTINE REGULARIZATION_NODIFF(routing_mesh, routing_parameter, &
& penalty)
  USE MOD_GAMMA_ROUTING_PARAMETERS_DIFF
  USE MOD_GAMMA_ROUTING_MESH
  IMPLICIT NONE
  TYPE(TYPE_ROUTING_MESH), INTENT(IN) :: routing_mesh
  TYPE(TYPE_ROUTING_PARAMETER), INTENT(IN) :: routing_parameter
  REAL, INTENT(INOUT) :: penalty
  INTEGER :: i, current_node, next_node, previous_node
  penalty = 0.
  DO i=1,routing_mesh%nb_nodes
!order matters
    current_node = routing_mesh%upstream_to_downstream_nodes(i)
    IF (i .LT. routing_mesh%nb_nodes) THEN
      next_node = routing_mesh%upstream_to_downstream_nodes(i+1)
    ELSE
      next_node = current_node
    END IF
    IF (i .GT. 1) THEN
      previous_node = routing_mesh%upstream_to_downstream_nodes(i-1)
    ELSE
      previous_node = current_node
    END IF
    penalty = penalty + 0.5*((routing_parameter%hydraulics_coefficient(&
&     current_node)-routing_parameter%hydraulics_coefficient(&
&     previous_node))**2.-(routing_parameter%hydraulics_coefficient(&
&     current_node)-routing_parameter%hydraulics_coefficient(next_node))&
&     **2.)**2.
    penalty = penalty + 0.5*((routing_parameter%spreading(current_node)-&
&     routing_parameter%spreading(previous_node))**2.-(routing_parameter&
&     %spreading(current_node)-routing_parameter%spreading(next_node))**&
&     2.)**2.
  END DO
END SUBROUTINE REGULARIZATION_NODIFF

